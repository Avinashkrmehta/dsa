WEBVTT

00:00.740 --> 00:03.170
This section is about trees.

00:03.170 --> 00:09.440
So we learn about general trees and binary trees and various types of binary trees.

00:09.470 --> 00:13.650
So in this video we learn about the terminology of trees.

00:13.880 --> 00:16.280
An Introduction to binary trees.

00:16.370 --> 00:23.480
So let us start with terminology see here I have taken in general tree nodes are containing alphabets

00:23.530 --> 00:26.190
so that it's easy for you to understand.

00:26.360 --> 00:32.700
Let us define our tree trimming is a collection of N or what is this.

00:32.770 --> 00:36.590
An actress notes an actress.

00:36.590 --> 00:38.530
These links are called as actions.

00:39.140 --> 00:46.460
If there are any laws then there will be and the minus one actress because for each nor do you can see

00:46.460 --> 00:48.730
that there is the edge coming over that note.

00:48.860 --> 00:54.500
There is an next coming over a dark note every Lord there is an edge coming from its spirit except the

00:54.500 --> 01:01.020
root of all this not having the edge coming from any pattern because that is the period of all the notes.

01:01.040 --> 01:05.430
So if there are any words says then there will be N minus one actress.

01:05.510 --> 01:13.100
This is a road north for the tree and if I look at only this portion all the laws below B then this

01:13.160 --> 01:19.690
is a suburb Tree Day and all the descendants of the old north.

01:19.690 --> 01:22.960
Below me is a subway train.

01:22.960 --> 01:31.140
So if you define entry three a collection of n among those known for one mode is taken as route north

01:31.550 --> 01:37.190
and rest of the north side are divided in two disjoint subsets.

01:37.390 --> 01:38.220
They are in subset.

01:38.230 --> 01:40.260
This is one subset does another subset.

01:40.310 --> 01:47.080
There is only one note in the subject and each a subset is a three again or subway tree again.

01:47.430 --> 01:53.170
So I repeat the definition a collection of north where one of the Lord is taken as a rule ignored and

01:53.170 --> 02:01.070
the rest of the north are divided in two disjoint subsets and each subset of the tree or some tree No

02:01.160 --> 02:04.630
let us look at the town's first route.

02:04.710 --> 02:15.850
The very first node on the top is a root parent and child a node is a parent to its very next to descendants.

02:16.000 --> 02:19.640
Are those children which are connected with just one edge.

02:19.810 --> 02:23.950
Are those descendants which are connected with one each so far.

02:23.950 --> 02:35.960
B e NF audits children forty g h i r children of the so d the parent of G H I and all are children of

02:36.140 --> 02:48.740
L L is a parent of an O so we have finished these now siblings siblings are children of same parent.

02:48.740 --> 02:51.740
G h i r children of D.

02:51.860 --> 02:55.020
So they are sibling to each other.

02:55.100 --> 03:05.530
G h i r siblings J and key are siblings because their parent the same and are siblings next descendants.

03:07.160 --> 03:14.360
For an ignored the set of four laws which are as children and their children and their children form

03:14.570 --> 03:20.480
or in other words their descendants are all those set of laws which can be read from a particular mortgage

03:21.050 --> 03:22.700
or under that.

03:22.820 --> 03:25.840
For example for B E F G.

03:25.850 --> 03:37.060
K M all these are descendants of B for L and then or are descendants for B G H I L and O all the laws

03:37.120 --> 03:39.000
that are reachable from D.

03:39.010 --> 03:49.280
Descendants of the next US ancestors so far ignored all the laws along the parts from that ignored group

03:49.310 --> 03:50.330
nor so far.

03:50.340 --> 04:00.310
M j f a b a r ancestors for an L h b a r ancestors.

04:00.380 --> 04:06.320
The next US degree often order degree of an order is in the middle for children it is having direct

04:06.320 --> 04:08.080
children not all descendants.

04:08.090 --> 04:14.090
Derek children beginning off as a do it is having two children niggardly over these a three degrees

04:14.090 --> 04:24.290
off a three degree office SS to a degree of GS 1 and degree of n is zero K is zero and a single number

04:24.290 --> 04:27.650
of children end in orders having is the degree of a norm.

04:28.190 --> 04:36.350
Then what is the degree of a three from the three we cannot tell what is the degree degree is a pretty

04:36.350 --> 04:44.330
tight act but if you observe what is the maximum degree of any order three three cities having three

04:44.330 --> 04:51.850
degrees this is having three degrees so their degree of four three can be minimum three minimum.

04:51.900 --> 04:55.480
At least it is three or it is more than three also.

04:56.100 --> 05:03.030
So I can explain you afterwards then coming to internal laws and external laws internal laws external

05:03.030 --> 05:09.720
laws are also called as and non-life norms and leaf laws are criminal laws or non-criminal laws what

05:09.720 --> 05:10.530
are those.

05:10.530 --> 05:19.680
N with the degree zero hour or less leaf n degree zero degrees zero degrees zero so E M K G C and or

05:19.750 --> 05:20.120
I.

05:20.370 --> 05:29.490
All these are leaf norms are external laws are government of laws and those laws whose degree is greater

05:29.490 --> 05:40.470
than zero are internal laws Nona leaf norms not that I mean a Lords next level its sea level of four

05:40.470 --> 05:47.400
trees starts from one on words that is ruled does at live one that is children at level two and their

05:47.400 --> 05:54.890
children eye level three and four and so on four level starts from one onwards.

05:54.970 --> 06:01.190
So actually for level we count n here one more horizontally.

06:01.210 --> 06:07.690
You see there is one more than at this level if you come closer to NATO either you can distort this

06:07.690 --> 06:07.980
too.

06:08.020 --> 06:09.810
We don't count all dorms.

06:09.910 --> 06:10.840
Just the pot.

06:10.840 --> 06:11.780
Pot in the pot.

06:11.780 --> 06:15.270
We will come to N until here the pot from root.

06:15.340 --> 06:16.540
That will take three north.

06:16.540 --> 06:17.850
One two three.

06:17.860 --> 06:21.930
Either you come here or you come here anywhere at this level.

06:21.970 --> 06:22.820
There are three Lords.

06:22.830 --> 06:24.120
One two three lords.

06:24.250 --> 06:27.860
Then at this level there are four notes one two three four notes.

06:27.970 --> 06:31.830
So we take the part by taking a number of N.

06:31.870 --> 06:40.720
So that's all at this levels the next is height of our tree height of a tree over the market here on

06:40.720 --> 06:41.790
this site.

06:41.790 --> 06:50.940
Who does that high 0 uninsured children hide one then hide to then hide three and four.

06:51.040 --> 06:56.950
See here we count edges here there are no edges no.

06:56.960 --> 07:01.030
If you come down to this next level or let us see a level only or part.

07:01.200 --> 07:03.380
Either you go here or here or here.

07:03.450 --> 07:04.830
Then how many are just out there.

07:04.860 --> 07:06.770
One edges one are just there.

07:06.780 --> 07:08.760
So this is taking one edge to reach here.

07:08.760 --> 07:14.840
One is 2D here at this horizontally at this level two are decided for one to do it just then still here.

07:14.850 --> 07:16.740
Three or just four inches.

07:17.100 --> 07:23.580
So level starts from one onwards and the height starts from zero on works high level both are useful

07:23.580 --> 07:26.850
for analysis not coming into the last term.

07:26.880 --> 07:32.920
That is forest a collection of trees is called as a forest for example.

07:33.030 --> 07:34.850
Here I will make a change.

07:34.920 --> 07:37.890
I have removed a root I have removed.

07:37.890 --> 07:39.810
How many trees do you see.

07:39.810 --> 07:47.860
This is one then this is just one single law degree and this is another put three trees are there so

07:47.900 --> 07:52.710
is a forest collection of trees of the forest and in fact only one to make it as a tree.

07:52.710 --> 07:57.930
By combining all the forests then you can introduce a note like this.

07:58.510 --> 08:04.810
So here a forest is converted to a tree for forests collection of trees.

08:04.810 --> 08:06.800
So that's all with the terminology.

08:06.800 --> 08:10.980
Now I will introduce you to a binary tree.

08:11.080 --> 08:11.400
No.

08:11.400 --> 08:21.250
There is a lot of old binary tree are tree offer degree to degree humans every node can have maximum

08:21.250 --> 08:29.210
2 children not more than 2 children it can have less than 2 children but not more than 2 children.

08:29.290 --> 08:38.540
So degree of a tree must be 2 if the degree is a 2 then it is called a binary tree by 2.

08:38.560 --> 08:39.340
So two children.

08:39.640 --> 08:47.950
So every node can have two children is having B and C B's having B and E likewise C is having f and

08:47.950 --> 08:52.420
g as there are only two children we will give the names to the children.

08:52.420 --> 08:57.510
This is left child and the society right child so far to be this left challenges the right child.

08:58.030 --> 09:00.470
So we give name fast left children right.

09:01.190 --> 09:09.400
One more definition of a binary tree that every node can have either zero children or one child or monster

09:09.470 --> 09:10.450
to children.

09:10.540 --> 09:16.600
So children can be either 0 1 or 2 not more than 2.

09:16.660 --> 09:20.800
Let us look at some examples of buying a tree.

09:20.860 --> 09:22.710
I've been told some by the trees.

09:22.860 --> 09:24.000
I did not label them.

09:24.040 --> 09:31.750
This is labelling ABC just ivory tower Domino's and look at the shape and find out whether it is a binary

09:31.750 --> 09:33.060
tree or not.

09:33.160 --> 09:35.180
Here I have some binary trees.

09:35.200 --> 09:39.510
First one is a binary tree.

09:39.670 --> 09:41.450
This is not having any children.

09:41.470 --> 09:45.570
Yes every node can have 0 1 or 2 children.

09:45.580 --> 09:47.260
How many children selling to children.

09:47.380 --> 09:48.410
OK perfect.

09:48.460 --> 09:49.110
How many children.

09:49.110 --> 09:53.320
Zero perfect 2 children perfect zero zero.

09:53.830 --> 09:55.420
Everything is perfect.

09:55.420 --> 10:01.790
What about this this node one child is perfect 0 1 or 2.

10:01.800 --> 10:03.810
Remember this this not one child.

10:03.990 --> 10:04.640
Okay perfect.

10:04.650 --> 10:06.230
This node 0 children.

10:06.240 --> 10:07.330
Perfect.

10:07.350 --> 10:13.450
This is also by native tree and this type of tree is called has left skew the tree.

10:14.190 --> 10:16.210
So this left skewed by many tree.

10:16.440 --> 10:18.270
And this one does another one.

10:18.270 --> 10:20.310
I'll just put the separation here.

10:20.340 --> 10:21.210
That is another one.

10:21.220 --> 10:23.670
Total one and that is also a binary tree.

10:23.670 --> 10:26.920
That is right skewed by native tree.

10:27.180 --> 10:29.230
What about this one.

10:29.400 --> 10:30.390
How many children.

10:30.390 --> 10:30.900
Three.

10:31.020 --> 10:31.680
No.

10:31.680 --> 10:32.640
This is not a name.

10:33.030 --> 10:35.030
So then they will say it's not a binary tree.

10:35.100 --> 10:40.860
If any node is having more than 2 children then you say it's not of my into less than 2 children it's

10:40.860 --> 10:41.680
not a problem.

10:42.780 --> 10:44.880
So does the binary does a binary.

10:44.880 --> 10:46.650
This is not a binary tree.

10:46.710 --> 10:48.750
This one is not a binary tree.

10:48.750 --> 10:49.980
Then what about 51.

10:50.980 --> 10:55.070
So this tree just rotated with some angle does the same.

10:55.060 --> 10:56.430
Is this fun.

10:56.430 --> 10:56.990
Yes.

10:57.090 --> 11:01.770
We draw the tree like this also instead of going left right.

11:01.770 --> 11:04.900
The child we draw down then right.

11:04.920 --> 11:09.020
Child so this shape is also possible.

11:09.020 --> 11:10.660
So we draw a tree like this.

11:11.030 --> 11:13.010
So Bunny trees are more commonly used.

11:13.010 --> 11:14.960
There are various forms of BI entries.

11:14.960 --> 11:16.370
We'll be learning them slowly.

11:16.880 --> 11:19.110
So in this video we have finished the topic.

11:19.130 --> 11:23.330
I have discussed the terminology and introduction to binary trees.


WEBVTT

00:00.120 --> 00:04.070
The topic is number of binary trees for a given set of notes.

00:04.170 --> 00:09.680
It means it's an awesome number of nodes are given like tree nodes are given.

00:09.690 --> 00:14.410
Then using three knows how many different binary trees can be generated.

00:14.430 --> 00:21.640
We are going to learn that we will learn about two type of nodes that is under labor laws and labor

00:21.660 --> 00:22.820
nodes.

00:22.830 --> 00:27.570
Let us start it under labor law nor does the example of labor laws.

00:27.570 --> 00:28.900
These are empty laws.

00:28.950 --> 00:33.420
Labelling is not their alphabets ABC or numbers 1 2 3.

00:33.420 --> 00:34.520
Nothing is written in that.

00:34.950 --> 00:37.160
So these are under labor laws.

00:37.290 --> 00:41.610
So if the three laws are given how many different binaries can be generated.

00:41.610 --> 00:43.330
I will draw them and show here.

00:43.530 --> 00:44.900
This is one ship.

00:44.940 --> 00:48.880
First one second ship that is Luke left and its right.

00:48.930 --> 00:49.960
Third ship.

00:50.150 --> 00:51.150
Read the three notes.

00:51.210 --> 00:53.750
Now next will be a mirror image of this one.

00:53.820 --> 00:58.160
The fourth one next will be mirror image of this not five different trees.

00:58.230 --> 01:04.410
So if there are three laws given number of trees if it is a function then the value of dysfunction is

01:04.410 --> 01:05.130
5.

01:05.160 --> 01:10.530
So if there are three nodes we can generate five different shared binary trees.

01:10.540 --> 01:10.910
Five.

01:10.960 --> 01:13.260
One two three four five.

01:13.410 --> 01:18.220
Next if there are four laws then how many different shaped by entries can be generated.

01:18.300 --> 01:20.980
Quite take four nodes number of nodes are four.

01:21.270 --> 01:25.510
These are four on level nodes every door different shaped by entries here.

01:25.710 --> 01:27.610
So here I have generated few.

01:27.690 --> 01:33.660
Look at them first one second third fourth fifth sixth segment.

01:33.910 --> 01:41.270
I've drawn seven then I get the mirror images and I can draw seven more.

01:41.310 --> 01:46.840
This is one shape so this is left skewed that also I can have right cube right.

01:46.860 --> 01:49.100
So for each I can have a mirrored image.

01:49.170 --> 01:50.850
So seven more I can draw.

01:51.040 --> 01:52.870
So I will complete that.

01:53.000 --> 01:55.730
Now I have all 14 traits.

01:55.770 --> 02:02.820
One two three four five six seven eight nine ten eleven twelve thirteen fourteen 14 different shapes

02:02.820 --> 02:04.090
of binary trees.

02:04.140 --> 02:10.620
So it means if number of nodes are four then we can have 14 differentiated binary trees.

02:10.680 --> 02:15.940
So far three nodes we got a number of trees are 5 and 4 four for also we got the number of trees as

02:15.980 --> 02:20.370
a 14 then for five nodes how many it will be for six nodes.

02:20.370 --> 02:21.330
How many it will be.

02:21.340 --> 02:23.440
Shall I drive retirement check them.

02:23.940 --> 02:24.550
No.

02:24.720 --> 02:29.100
Just for observation I have drawn that explaining what does it mean by number of trees.

02:29.100 --> 02:30.920
I have drawn them right now.

02:30.930 --> 02:37.090
There must be some formula for this one yes there is some formula that formalized number of trees for

02:37.090 --> 02:45.730
a given number of Nords are two N C and bi and plus one.

02:45.780 --> 02:47.200
This is the famous formula.

02:47.250 --> 02:50.720
The name of this formalize Catalan number.

02:51.040 --> 02:54.250
There's a known formula to NC and by and plus 1.

02:54.440 --> 03:00.450
So if adenoids are given then these many number of binary trees can be generated.

03:00.930 --> 03:02.380
So far 5 how.

03:02.460 --> 03:11.050
Let me calculate P 5 will be 2 will do 5 c 5 by 5 plus 1.

03:11.100 --> 03:17.020
This is 10 C 5 by 6 N C 5 by 6.

03:17.220 --> 03:24.510
And this is then you don't need to wait in 2 7 2 6 divided by 5 into 4 into three groups with one holding

03:24.510 --> 03:25.530
divided by 6.

03:25.530 --> 03:36.010
No let us divide this and get done so 6 6 6 gets cancelled 5 dos 10 is gone for DOS 8 and 3 3s.

03:36.020 --> 03:36.640
9.

03:36.840 --> 03:40.020
So this is 3 to 2 in 2 7 is remaining here.

03:40.170 --> 03:41.460
So this is 42.

03:41.850 --> 03:44.480
So the 5 is 42.

03:44.650 --> 03:50.640
So for any given number of n you can find out how many differentiated binaries can be generated if at

03:50.640 --> 03:54.130
all you want to try out and see how Wall Street looks like.

03:54.180 --> 03:55.730
Then you have to draw all of them.

03:55.730 --> 04:01.470
That will not be practical so have just shown for 3 nodes and 4 n no one more observation I have to

04:01.470 --> 04:07.770
do here see then three nodes are given what could be the maximum height height starts from zero on what

04:07.770 --> 04:10.670
so 0 1 2 0 1 2.

04:10.740 --> 04:18.030
So the maximum height possible is to the strings of height two and 2 and this is not a 2 This is 1 to

04:18.070 --> 04:18.780
2.

04:18.900 --> 04:23.220
So how many trees are there but the maximum height.

04:23.220 --> 04:24.500
1 2 3 4.

04:25.110 --> 04:28.810
So the number of trees with the maximum height are 4.

04:28.830 --> 04:31.590
So that is 2 square.

04:31.590 --> 04:34.790
This is for how many n n equal to 3 nodes.

04:34.800 --> 04:39.000
Then what about an equal to 4 laws number of trees at maximum height.

04:39.000 --> 04:41.200
Let us count them 0 1 2 3.

04:41.220 --> 04:45.070
Yes this is maximum height because there are four nodes so the height should be maximum 3.

04:45.360 --> 04:48.860
So 1 2 3 4 does not maximum.

04:48.870 --> 04:51.450
No no no no no.

04:51.450 --> 04:52.210
Yes.

04:52.350 --> 04:53.930
5 6 7 8.

04:54.330 --> 04:58.110
So 8 trees are there with the maximum height.

04:58.290 --> 05:01.710
So this is 2 cube so far and equal to 5.

05:01.710 --> 05:05.510
How much it will be you can guess now 16.

05:05.790 --> 05:08.700
Yes this is two point four so for any n.

05:08.730 --> 05:12.390
How many trees will be added to power and minus one.

05:12.690 --> 05:19.050
So we have learn how many different shaped by trees can be generated for a given number of N so we don't

05:19.050 --> 05:20.320
have to generate the tree.

05:20.460 --> 05:21.690
We can use the formula.

05:22.140 --> 05:27.240
And one more observation rather than how many binary trees are possible that the maximum height.

05:27.240 --> 05:29.780
So that is two part and the minus one.

05:30.210 --> 05:37.300
Let us generate one more formula for Catalan number I will right on two values of Catalan number.

05:37.320 --> 05:41.880
Then from that legacy how we can come up with one more formula for Catalan number.

05:42.090 --> 05:45.810
So first of all I will take the table of values for Catalan number.

05:45.830 --> 05:51.050
See if any is given then Catalan number in that we know the answer.

05:51.060 --> 05:55.320
Formula 2 when C n by and plus 1.

05:55.320 --> 05:55.830
See here.

05:55.830 --> 05:57.960
Value often and this is the Catalan number.

05:58.200 --> 06:04.270
So I would take the values off and then write on the Catalan number of others also see if it is 0.

06:04.290 --> 06:14.490
Then if you put 0 in this formula you get 1 then if it is 1 then it is still 1 4 2 this 2 for 3 the

06:14.490 --> 06:21.990
anode on phonetically just not we saw then for 4 it is 14 for 5 it is 42.

06:22.110 --> 06:25.520
So far 6 I will find out using a different method.

06:25.530 --> 06:26.860
I will not use this formula.

06:27.390 --> 06:28.610
So just watch this one.

06:29.670 --> 06:32.290
I want done so 4 6.

06:32.430 --> 06:44.170
So for that I will multiply these values 1 into 42 plus 1 and go 14 plus two into five plus five input

06:44.190 --> 06:45.200
to see.

06:45.300 --> 06:53.440
It was to win the fight now 5 into 2 plus 14 into one plus 42 in Q1.

06:53.460 --> 06:59.860
This gives the answer 4 6 so that a third of this one is one thirty two.

07:00.950 --> 07:05.900
Let us use the forum allow for value the six and check whether our answer is correct or not.

07:05.900 --> 07:15.860
Let us very fine these 6 is 2 2 6 2 N C and bright during the 6 C 6 by 6 plus 1.

07:16.670 --> 07:20.630
So this is twelve C six by seven.

07:22.250 --> 07:24.290
This is this is the numerator.

07:24.290 --> 07:27.410
Then that number will be 7.

07:27.410 --> 07:40.310
Let us cancel these 7 7 guess cancel 6 2s tool gets cancelled 5 to 10 for pools 8 3 3s 9 remaining is

07:40.430 --> 07:46.550
leaven and 2 2 and 2 3 in 2 2.

07:47.030 --> 07:59.390
So this is level 2 2 3 6 6 to 12 so Levon incorporated 132 so yes we got the correct answer by substituting

07:59.450 --> 08:01.790
in this forum alone so we got the correct answer.

08:02.180 --> 08:06.740
So how I got this one I multiplied this fund with this fund and this fund funded this fund and this

08:06.740 --> 08:10.100
too done this to then this tool then this tool.

08:10.130 --> 08:12.080
So let us prepare a forum for that fund.

08:12.290 --> 08:13.720
So this is D6.

08:13.760 --> 08:26.690
So this is D zero in two forty two is t five B five plus B one in group B forward then D.

08:27.140 --> 08:28.990
So the devalues we are multiplying right.

08:29.330 --> 08:41.240
So do it would be three then B three in duty to then t forward into P 1 then P 5 it would be zero.

08:41.540 --> 08:45.740
So these are the tone and each term is a product of two values.

08:45.740 --> 08:54.420
So this can be done in general form T and then is a summation of two values P of something and beauty

08:54.460 --> 08:55.160
of something.

08:55.160 --> 09:00.200
So what is this does starting from zero one two three four up to five.

09:00.620 --> 09:06.950
And this is five four three two one so one sided is increasing the other parties decreasing so this

09:06.950 --> 09:08.420
is increasing this is decreasing.

09:08.630 --> 09:14.960
So if I take a value starting from 1 to N then I should say a minus 1 because I had moments last time

09:14.960 --> 09:15.650
which would be zero.

09:16.040 --> 09:28.730
And this is and the minus I C S we got the formula so Catalan number de m as 2 and C and by and plus

09:28.730 --> 09:31.690
1 2 and C and by N plus 1.

09:31.700 --> 09:32.830
This is one formula.

09:33.140 --> 09:42.720
And the other one is summation of IBEX values from one grand I minus one in to peel off and minus I.

09:43.310 --> 09:45.860
So the Catalan number can also be written like this.

09:45.950 --> 09:47.930
These are combination formula.

09:48.230 --> 09:49.940
And this is a recursive formula.

09:50.000 --> 09:52.330
So that's all about the formula.

09:52.400 --> 09:54.900
Catalan formula we have got to formula.

09:54.980 --> 10:01.660
Now we have to learn about labor the N so I will remove this and I'll explain your vote liberal landlords

10:01.840 --> 10:07.930
not to see Labour Laws labour law means these three laws are there now you can see they are Labour right

10:07.940 --> 10:11.410
and previously they were no labels here they were blank.

10:11.440 --> 10:14.680
Now something is written in that so labelling is done.

10:14.780 --> 10:21.560
So ABC are labels that if Labour laws are there then how many different entries can be generated.

10:21.590 --> 10:26.240
That's what we have to find out for without label all that if you know the answer without labels.

10:26.240 --> 10:30.880
There are five and foreign lies to NC and my plus one.

10:31.070 --> 10:36.350
We all know the farm loan does the farm loan and for 14 or sunset is five.

10:37.010 --> 10:44.750
But no these are liberal for liberal means if I pick up just one tree this tree if I become then this

10:44.750 --> 10:45.590
is unleavened.

10:45.890 --> 10:53.840
So if I try to label it how many ways I can never let three levels can be filled in how many ways.

10:53.840 --> 10:56.040
Three factorial ways.

10:56.060 --> 11:07.790
Let us see just over label this a B C and one more labelling a CB same three shape is same but the labels

11:07.790 --> 11:16.020
are a change permutation of label has change so they have different ways of filling ABC ACB B A C B

11:16.180 --> 11:19.480
C E C A B C V A.

11:19.640 --> 11:21.690
So one two three four five six.

11:21.710 --> 11:27.810
So yes these are six means this is three factorial so one shape can be for little three factorial is

11:28.070 --> 11:34.030
second shape again three factor three factor three factor for every shape and three factorial ways.

11:34.160 --> 11:42.530
So far three nor so three factorial four unknowns and factoring does the formula so for liberal n formalise

11:43.100 --> 11:49.440
to N C and men plus 1 in 2 and factorial because the filling of the labels.

11:49.550 --> 11:57.770
So if you look at this form and separated into two parts this part is four shapes and this part is for

11:58.310 --> 12:02.330
filling permutation in how many ways n can be further.

12:02.900 --> 12:08.840
So this gives you how many different shapes we can get to five different shapes then and factorial gives

12:09.080 --> 12:14.660
one shape can be found in how many ways that is n factor in these seven the notes are Labour then thus

12:14.650 --> 12:15.070
far.

12:15.110 --> 12:17.530
So that small end of the topic.

12:19.010 --> 12:25.510
So we have learned number of North versus number of four different shared by many trees.

12:26.000 --> 12:31.040
So this discussion of this analysis is useful further in other topics.


WEBVTT

00:01.130 --> 00:08.320
This topic is about former US high towards a small forum loss for business.

00:08.570 --> 00:14.690
If we know the height of a binary tree what could be the minimum number of nodes and what could be the

00:14.690 --> 00:18.010
maximum number of nodes and vice versa.

00:18.050 --> 00:22.590
If nodes are given what could be minimum height what could be maximum height.

00:22.610 --> 00:23.960
We are going to discuss this.

00:24.800 --> 00:26.640
So first let us learn.

00:26.780 --> 00:34.190
If height of a binary tree is given then what could be the minimum number of n what could be the maximum

00:34.190 --> 00:37.190
number of nodes already I have taken few examples.

00:37.190 --> 00:39.090
Let us study these examples.

00:39.230 --> 00:43.250
Height of a binary tree is given height as one side starts from zero.

00:43.250 --> 00:43.510
Right.

00:43.820 --> 00:44.920
So this is 0 and 1.

00:45.260 --> 00:46.210
So how does one.

00:46.490 --> 00:53.440
So in the hype 1 minimum how many Northside required to reach height 1 2 nodes.

00:53.570 --> 00:57.260
If I remove the node then only one law it will not be height 1.

00:57.440 --> 01:03.280
So minimum 2 nodes are needed to make a tree of height one then in that height of 1 maximum.

01:03.290 --> 01:04.790
How many nodes are possible.

01:04.790 --> 01:06.770
1 2 3 UNRWA.

01:07.650 --> 01:14.250
Likewise if height is 2 then for making a tree of height cool minimum how many nodes required.

01:14.270 --> 01:17.820
1 2 3 maximum 7 nodes.

01:17.990 --> 01:20.870
Likewise height is 3 minimum nodes.

01:20.960 --> 01:26.630
Many maximum loans this many if we don't want to count we want a formula.

01:27.140 --> 01:30.830
So so from observation we can generate the formula.

01:31.280 --> 01:33.870
So first let us check minimum number of n.

01:34.070 --> 01:42.850
If height is 1 minimum 2 n high this 2 minimum 3 nodes height is 3 minimum for N so minimum lowest form

01:42.860 --> 01:46.400
level B height plus 1 C height plus 1.

01:48.410 --> 01:54.380
So minimum nodes an equal to each plus 1.

01:54.410 --> 01:55.310
This is one forum.

01:55.310 --> 02:05.230
Loving God No he won the formula for maximum n 3 7 15.

02:05.540 --> 02:13.980
We don't find any PAC on like there was a pattern here haikus or tree height 3 or 4 so high plus 1 but

02:14.520 --> 02:17.590
3 7 15.

02:17.940 --> 02:27.060
Let us observe from this street how we got 15 we got 15 because this is one node and in this level there

02:27.060 --> 02:31.830
are two nodes and this Eleven one two three four four nodes are there.

02:31.830 --> 02:38.050
That is two square nodes and in this level one two three four five six seven eight to kill more one

02:38.050 --> 02:38.710
sided.

02:39.840 --> 02:45.160
So this is one plus two plus two squared plus two.

02:45.150 --> 02:48.400
Q This answer is 15.

02:48.960 --> 02:52.580
So all these notes when they are added It is becoming 15.

02:52.920 --> 02:56.930
So one plus two plus two squared plus two cube is giving 15.

02:57.030 --> 03:00.390
So is there any formula for this one.

03:00.390 --> 03:02.060
Let me show you the formula.

03:02.140 --> 03:08.060
Say this is G.P.S. these ay are a square cube.

03:08.250 --> 03:10.920
So on to a r power k.

03:11.400 --> 03:15.660
So this is a GP series and all the terms of GP series are added.

03:16.200 --> 03:23.830
So some of these don't fall for GP ICD that is a job that is geometry progression.

03:23.830 --> 03:28.670
Some of the columns of G.P.S. these smooth geometric progression series.

03:28.780 --> 03:30.910
So there is a known formula for this one.

03:31.060 --> 03:39.790
This is E R to deport of K plus one minus one by R minus one.

03:39.850 --> 03:41.940
The Samoan formula.

03:41.940 --> 03:46.420
Now this looks like G.P.S. this only let me write on that one.

03:46.480 --> 03:47.530
See I have written this one.

03:47.530 --> 03:52.740
One plus two plus two squared plus two Q goes on to recoup over each.

03:53.500 --> 04:03.490
Then what is a in this one is one then what is odd in this one odd is to see for each storm coefficient

04:03.580 --> 04:06.000
it is not there not demonstrate just one.

04:06.400 --> 04:08.370
So is one an artist too.

04:08.470 --> 04:12.910
So I will use this formula and I will write on it as an R as two.

04:13.240 --> 04:22.360
So this is is one artist to power what is the maximum time I have taken each entry plus one minus one

04:22.720 --> 04:26.050
by artist to so two minus one.

04:26.590 --> 04:33.370
So if I simplify this this is to part each plus one minus one divided by two minus one is one.

04:34.030 --> 04:42.290
So that is a dancer so if you take the sum of this dance up to each then this is two bodies plus or

04:42.280 --> 04:44.240
minus one.

04:44.310 --> 04:45.840
Let us come back to this example.

04:45.840 --> 04:47.370
Height was a tree.

04:47.430 --> 04:52.140
So one plus two plus two squared plus two cube up to three higher the three.

04:52.500 --> 04:58.160
So this is nothing but two power s plus one minus one so two polity plus one minus one.

04:58.290 --> 05:02.280
Let us put the values here so two bar three plus one minus one.

05:02.370 --> 05:07.170
This is too powerful minus one and this is sixteen minus one.

05:07.230 --> 05:08.230
So this is 15.

05:08.250 --> 05:12.080
Yes it is correct it is correct.

05:12.090 --> 05:17.170
So back to value fifteen is some multi terms of the G.P.S. these.

05:17.180 --> 05:24.030
So these are some of data for the G.P.S. these so these are G.P.S. these stones if we take maximum n

05:24.600 --> 05:29.490
so that is similar to this one we already know the formula we have used the same formula now we got

05:29.490 --> 05:38.210
the formula for maximum n so we already have four minimum n I will remove this I will write on for maximum

05:38.260 --> 05:48.380
notes so formula for maximum loads and equal to to Bar H plus one minus one.

05:48.440 --> 05:56.540
So now we know the formula is high for binary trees given then within that height minimum we need X

05:56.540 --> 06:02.350
plus one n maximum two borders plus one minus for number of nodes are possible.

06:02.400 --> 06:10.430
All right so these formulas are very important for binary tree No I need the formulas in other me if

06:10.430 --> 06:16.390
a more bizarre given what will be the minimum height what will be the maximum might here we know height

06:16.490 --> 06:24.470
so we formed rock n no next we will be doing laws we want height citing same formulas we can use.

06:24.470 --> 06:31.460
Let us see first I will take some examples then we will discuss this now if the number of Nords are

06:31.460 --> 06:36.920
given we have to find out what could be the minimum height what could be the maximum height for those

06:36.920 --> 06:38.240
number of nodes.

06:38.240 --> 06:43.420
So here I have already take on some examples using greenhorns.

06:43.460 --> 06:46.980
I can generate by the key of the minimum height.

06:47.300 --> 06:51.350
1 0 1 and that same 3 node.

06:51.350 --> 06:57.390
I can stretch the height up to maximum 2 0 1 2 4 3 nodes.

06:57.590 --> 07:03.350
Next I have taken an example of 7 n 4 4 7 nodes 1 2 3 4 5 6 7.

07:03.350 --> 07:10.810
Does the minimum height height is true that is 0 1 2 and these 7 nodes maximum height of 6.

07:10.830 --> 07:16.510
Then for 15 n minimum height is 3 maximum height is 14.

07:16.680 --> 07:21.890
No we want the formula for the minimum and maximum.

07:21.890 --> 07:25.360
First of all we will find the formula for maximum.

07:25.370 --> 07:29.560
Let us set maximum maximum height for 3 lords high.

07:29.560 --> 07:35.850
This tool for 7 lords high to 6 for 15 lords height is 14.

07:36.500 --> 07:40.120
So this some pattern whatever the Lords are high.

07:40.220 --> 07:41.980
This one less than that.

07:42.140 --> 07:45.110
Noah's are seven so height to 6 Noah's Ark 3 so high.

07:45.110 --> 07:46.600
This too so high.

07:46.600 --> 07:49.070
This one less than the number of nodes.

07:49.460 --> 07:58.850
So yes we got the formula for maximum height so maximum height formula etches equals 2 and minus 1.

07:58.940 --> 08:00.130
We got the formula.

08:00.260 --> 08:02.560
Now what is the minimum height formula now.

08:02.870 --> 08:09.500
If I check the minimum high number of nodes are three so minimum height is one number of nodes are seven.

08:09.530 --> 08:13.900
So minimum height is to number of nodes are 15 so height the street.

08:14.150 --> 08:15.770
So I don't find any pattern here.

08:16.860 --> 08:18.620
So I'll show you something here.

08:18.630 --> 08:25.080
See these are the formulas just small we have found out if height is given than minimum norms and maximum

08:25.080 --> 08:30.780
norms we have all the formula minimum north and east coast which puts one maximum NS equals two and

08:30.780 --> 08:32.490
there's two bodies plus one minus one.

08:32.490 --> 08:39.100
We have seen this formula now we are finding out now if the Nords are given.

08:39.100 --> 08:43.340
Then find out minimum and maximum height if North are given.

08:43.360 --> 08:47.440
So for that maximum height we got etches equal sure and minus one.

08:47.440 --> 08:52.150
So that system similar to this one just goes to and minus one that is equal to.

08:52.150 --> 08:55.030
And this plus one you send it there for minus one.

08:55.330 --> 08:57.780
So this was the minimum North formula.

08:57.820 --> 08:59.920
It became maximum height formula.

09:00.250 --> 09:05.860
So it means maximum Nord formula can be converted in to minimum height formula.

09:06.310 --> 09:08.970
So I don't have to observe the crease.

09:09.040 --> 09:11.430
Let us use this formula and can work it.

09:11.720 --> 09:15.720
OK so what is the formula and is equal to two parties plus one minus one.

09:15.790 --> 09:17.010
So I will find out here.

09:19.040 --> 09:23.330
And as equals to portage plus one minus one does the formula right.

09:23.690 --> 09:34.120
This is for maximum n so this I can right it does and plus 1 as equals 2 to bar H plus 1 that minus

09:34.120 --> 09:42.130
one I brought it here then I'm enjoying the side so two bodies plus one as equals two and plus 1 not

09:42.370 --> 09:48.240
each plus 1 is log base 2 and plus 1.

09:48.580 --> 09:52.320
So if you send this base to that side it becomes log.

09:52.720 --> 09:55.160
So each plus ones equals two log base two plus four.

09:55.630 --> 10:05.470
Finally this edge is equal to log base 2 and plus 1 and this plus 1 if I sent it there minus 1.

10:05.830 --> 10:10.610
So I got the formula for each X as equals to log me is 2 and plus 1 minus 1.

10:10.720 --> 10:14.620
From where I got the sun from this one scene from this forum a lot.

10:14.740 --> 10:23.760
This was in terms of x to find out and I converted it in terms of and we'll find out each this has done

10:23.760 --> 10:26.770
so for minimum height.

10:27.320 --> 10:28.870
Minimum height.

10:29.450 --> 10:34.040
Safe and loads are given the minimum height will be based on this formula.

10:34.760 --> 10:36.390
Let us verify this fun.

10:36.410 --> 10:38.270
See I'm having 15 nodes.

10:38.390 --> 10:39.660
What would be the minimum height.

10:39.680 --> 10:48.200
We know down to three that a circuit edges equals to log 15 plus one minus one.

10:48.230 --> 10:57.050
So this is log 16 base to log 16 base to minus one log 16 is how much four minus one.

10:57.050 --> 10:59.300
This minus one as it is this minus one.

10:59.360 --> 11:00.110
This is three.

11:00.200 --> 11:01.950
Yes we are getting the answer.

11:02.210 --> 11:06.300
So from these formulas we can derive other formulas.

11:06.440 --> 11:07.030
Right.

11:07.040 --> 11:11.580
So if you know the formula for higher you can get the formula for nodes.

11:11.720 --> 11:19.700
So I will write on those formulas as equals to and the minus one edge is equal to minimum formula that

11:19.700 --> 11:28.460
is log base 2 and plus one minus one maximum formula and the minus one.

11:28.460 --> 11:34.580
So he got the formulas so I will remove this and finally show you two formulas these formulas.

11:34.580 --> 11:35.730
I'll show them here.

11:35.870 --> 11:40.370
Finally from the observation we got a range of values.

11:40.450 --> 11:45.940
See first form farm lobby follows this one number of laws in a binary tree.

11:46.040 --> 11:53.780
Number of n minimum s plus 1 maximum 2 parties plus 1 minus.

11:53.780 --> 12:00.260
This is based on height if you know the height of a binary tree then in that by the tree minimum number

12:00.260 --> 12:05.800
of nodes can be these many maximum number of nodes can be d from any next.

12:05.840 --> 12:09.350
We saw this formula high def a binary tree.

12:09.380 --> 12:11.190
This is very important.

12:11.300 --> 12:20.970
Height of a binary can range from log in to n logarithmic to linear.

12:20.970 --> 12:31.910
Then this is order of log in and this is order of N so minimum must log in magazine on this and so height

12:31.910 --> 12:35.200
of a binary tree can range from log into it.

12:35.370 --> 12:41.900
I remember this one always so binary agreements log into an whatever the border log I have done you

12:41.900 --> 12:45.020
do it once then you will always remember this for us.

12:45.050 --> 12:46.580
These farmers are very important.



WEBVTT

00:00.350 --> 00:06.750
Now we are going to find out the relationship between internal laws and external laws.

00:06.780 --> 00:09.990
That is a non-life NWS leaf notes.

00:10.350 --> 00:13.620
So far finding the relationship already you have some examples.

00:13.620 --> 00:19.590
So let us find out at least n and on live n then we will see if there is any form line between them.

00:19.590 --> 00:21.630
Is there any relationship between them.

00:21.720 --> 00:28.290
So let us find out here how many nodes are there but the degree to number of nodes with the degree to

00:29.610 --> 00:31.810
this is having two children sort of critical.

00:31.890 --> 00:33.330
This also having good.

00:33.350 --> 00:35.720
So degree to any of them you know.

00:36.180 --> 00:40.740
So there are two nodes for the degree to then how many laws are the degree one.

00:41.550 --> 00:43.900
This is having just one child beginning one.

00:44.070 --> 00:50.150
This also having just one child degree one so to know what's with the degree one that how many laws

00:50.150 --> 00:56.770
are there with a degree zero one two three three and the one sided with the degree.

00:56.790 --> 01:03.880
SIEGEL So I have found out all the more that the degree to degree one and degree zero.

01:04.110 --> 01:07.210
Right so I do the same thing for other two examples also.

01:07.230 --> 01:14.940
Then we will see is there any formula industry number of nor to the degree to does having both the children

01:15.120 --> 01:20.160
degree too does having both the children degree to this having both the children degree to any other

01:20.160 --> 01:21.000
more than No.

01:21.010 --> 01:24.630
So 1 2 3 3 and also the degree to that.

01:25.590 --> 01:32.010
How many laws are having degree one this is having a degree like this also having degree one does also

01:32.010 --> 01:37.030
having degree one so one two three and this also having degree one does also having negative and so

01:37.030 --> 01:39.840
put on how many 5 n 5.

01:39.940 --> 01:41.840
One two three four five.

01:42.420 --> 01:48.240
Then how many know what's with the degrees zero one two three four.

01:48.270 --> 01:50.300
These notes are not having any children.

01:50.370 --> 01:58.000
So degree zero also 4 c these are internal laws and this is external law right.

01:58.020 --> 01:59.770
These are internal and external.

02:00.210 --> 02:05.540
So these two together internal means they must have either two children or one child no children 0 2

02:05.540 --> 02:13.560
elements leaf not like external laws there is observer here how many laws for the degree to live on

02:13.980 --> 02:21.510
yes how many laws with the degree one does having degree one two three four four and also the degree

02:22.110 --> 02:31.930
one then how many and also the degrees 0 1 and 2 so 2 I have read on the values here.

02:32.150 --> 02:37.700
So there are some hints I have given in this values you find out what is the relationship.

02:37.710 --> 02:49.370
2 3 3 4 1 2 so there is a relationship between nought for the degree to 1 degree 0 but not degree 1

02:49.670 --> 02:52.940
but not degree 1 the degree 2 and degree 0.

02:52.940 --> 02:53.920
There is a relationship.

02:54.200 --> 03:00.950
So what is the relationship number of n with their degrees 0 are equal to number of moods with the degree

03:00.950 --> 03:14.160
to plus 1 Yes this is always true in binary tree this forum lies always true in binary tree so that's

03:14.180 --> 03:19.730
all about the form the relationship between internal laws and external laws we have seen.




WEBVTT

00:00.180 --> 00:05.690
We will learn about strict binaries strict boundaries are also called as a property by the entry or

00:05.700 --> 00:09.330
some vendor on Four Corners complete by native tree.

00:09.390 --> 00:15.540
The stable trees for analysis if you have a binary tree and you found that it is a strict then whatever

00:15.540 --> 00:19.540
the analysis are learning that are suitable for that stick by the tree.

00:19.950 --> 00:24.030
So you'll be learning height towards the stones that we have what it is seen in binary tree.

00:24.510 --> 00:31.440
So here what are the changes we will look at then into the Lord's forces extend on Lords this also we

00:31.440 --> 00:33.290
have done by military.

00:33.510 --> 00:38.240
Let us see what is the formula for into the next some notes in strict boundaries.

00:38.580 --> 00:41.430
So let us find out what are sick by the entries.

00:42.610 --> 00:49.120
So first of all let us know what autistic by nature is a general by military means every Lord can have

00:49.480 --> 00:52.270
zero one or two children.

00:52.480 --> 00:59.690
But in their strict Money Tree a lord can have either a zero children or exactly two children.

00:59.740 --> 01:05.940
A note cannot have one child so stick means it must be strictly binary.

01:05.980 --> 01:09.480
This should not be any Lord with the dignity one that is unity.

01:10.420 --> 01:12.360
So here I have some examples.

01:12.370 --> 01:17.410
Let us take those examples to understand more clearly about sticking by the.

01:17.470 --> 01:20.070
Let us look at this binary tree.

01:20.070 --> 01:21.520
This is known as having two children.

01:21.730 --> 01:22.360
OK.

01:22.490 --> 01:24.460
Allowed this note is having children.

01:24.520 --> 01:25.230
Yes.

01:25.360 --> 01:27.760
This note is having two children allowed.

01:27.790 --> 01:28.820
What about this note.

01:28.840 --> 01:30.450
No children for this one.

01:30.460 --> 01:31.510
What about this note.

01:31.600 --> 01:34.330
Degrees zero degrees zero degrees zero.

01:34.360 --> 01:34.830
Yes.

01:34.870 --> 01:36.220
Perfect.

01:36.220 --> 01:40.810
What about this degree 2 degrees zero degrees two degrees zero degrees.

01:41.380 --> 01:41.670
Yes.

01:41.680 --> 01:42.270
Perfect.

01:42.910 --> 01:48.370
Whatever this one degree 2 degrees zero degrees one degree one does not allow.

01:48.790 --> 01:52.340
So this is not a stick by military.

01:52.440 --> 01:54.970
What what this 1 degree 2 degree 1.

01:55.270 --> 01:57.840
So because of this are there are other also.

01:57.850 --> 01:59.020
This one is also there.

01:59.320 --> 02:06.510
So because of these laws and it's not a string but a three this one for this law degrees and 3.

02:06.970 --> 02:08.810
So this is not developed by the tree.

02:08.890 --> 02:11.630
Let us look at this one beginning 1 degree 1.

02:11.650 --> 02:14.490
So this is not a stick by a tree.

02:14.500 --> 02:20.470
So in this example these two are stringed by the tree and stop them are not by nature trees and this

02:20.470 --> 02:21.900
is not even a Band-Aid.




WEBVTT

00:00.840 --> 00:01.880
Let us look at hide.

00:01.930 --> 00:02.390
Watch this.

00:02.390 --> 00:05.230
Notes for that already I have taken some example.

00:05.790 --> 00:11.610
Let us look at the examples here I have taken a hired to do so in height to minimum these many notes

00:11.610 --> 00:19.830
are possible maximum D that is 7 and here height is 3 minimum no 7 maximum 15 and height is for a minimum

00:19.830 --> 00:27.090
9 and maximum 31 I did not draw the company treated if you observe the maximum number of nodes maximum

00:27.090 --> 00:34.210
number of nodes are C mass of binary three formula maximum number of nodes are same but it is just a

00:34.200 --> 00:40.620
one in three or a strict binary then what is different here minimum number of notes see if it is just

00:40.620 --> 00:46.500
above the three then these laws are not required minimum three nodes are sufficient but here five nodes

00:46.530 --> 00:49.130
because it has to be strict so far being strict.

00:49.130 --> 00:54.530
Every node must have either zero or two children so five nodes seven and nine.

00:55.110 --> 00:58.990
So what is the formula 5 7 9 next.

00:59.130 --> 01:03.000
It may be 11 that 13 so it's going back or no.

01:03.000 --> 01:11.070
So we need the formula for minimum if height is true then two plus two plus one.

01:11.090 --> 01:19.100
So two in the two plus one if height is three to two to four three times two then group one so doing

01:19.130 --> 01:22.120
two three plus one I mean height is a four.

01:22.130 --> 01:27.720
So this is two two nodes two moves to noon so four times two plus one.

01:27.770 --> 01:30.240
So what is the formula now.

01:31.070 --> 01:37.760
So now we can frame the formula whatever the height is to and go height plus one minimum number of nodes

01:37.760 --> 01:39.970
are two in two height plus one.

01:40.310 --> 01:44.050
What is the formula for maximum n to what age plus one minus 1.

01:44.040 --> 01:45.360
We already know that.

01:45.400 --> 01:47.810
So like we laid on the formula here.

01:48.080 --> 01:51.650
If height of offer stick by a tree is given then minimum.

01:51.650 --> 01:53.170
How many nodes are required.

01:53.270 --> 02:00.670
Just now we have found the formula that is to include each plus 1 then maximum how many nodes are possible

02:00.680 --> 02:01.590
maximum.

02:01.670 --> 02:06.720
This is same formula to board x plus 1 minus 1.

02:06.950 --> 02:13.700
These are the formulas if height is a given and we have to find nodes then what are the formulas if

02:13.700 --> 02:17.800
the laws are given and we have to find out minimum and maximum height.

02:18.200 --> 02:23.870
So those sort of laws we can obtain them from here although we have learned and by the decree that if

02:23.870 --> 02:29.600
you know these two formulas just convert them we can know the formula for height.

02:29.600 --> 02:32.710
So let me write on the formula here here.

02:32.810 --> 02:39.170
If any laws are given then what is the minimum height and what is the maximum height so minimum height

02:39.200 --> 02:41.790
we can get it from this maximum formula.

02:41.840 --> 02:48.830
This is an equal to so-and-so and in comes of age we should come contradict each equal to whatever the

02:48.830 --> 02:50.340
form lies in terms of.

02:50.600 --> 02:53.360
So we have already converted this in the previous video.

02:53.450 --> 02:56.470
So this is log n plus 1 base 2 minus 1.

02:56.990 --> 03:02.240
Yes this is log base 2 and plus 1 minus 4.

03:03.790 --> 03:08.650
Then whatever the maximum height formula that we can get it from minimum note formula for any call to

03:08.650 --> 03:10.150
do X plus 1.

03:11.290 --> 03:20.400
So what I did in terms of N so is equals 2 and minus 1 by 2 and minus 1 by 2.

03:21.150 --> 03:21.740
So that's it.

03:21.750 --> 03:26.600
These are the formulas now here the formula for height is important.

03:27.020 --> 03:34.970
So height if you observe minimum height this log in B is to log in plus one base to minus 1 and the

03:34.970 --> 03:37.760
maximum height this and the minus 1 by 2.

03:38.270 --> 03:43.100
So if you observe this one this is logarithmic and this is linear.

03:43.100 --> 03:51.290
So height is arranging from log to and now so the height properties similar to binary tree only that

03:51.290 --> 03:53.480
is maximum height can mean comes off n.



WEBVTT

00:01.500 --> 00:05.380
Now let us look at internal laws versus external laws.

00:05.430 --> 00:08.130
That is that is non-life known sources.

00:08.130 --> 00:11.340
Leaf nodes of a stick binary tree.

00:12.420 --> 00:15.920
So for explanation all that you have taken some examples stick by trees.

00:15.960 --> 00:16.890
Let us look at them.

00:18.010 --> 00:21.560
Set this straight Banyan entry how many into the laws.

00:21.580 --> 00:24.070
One and 2 going down the NSA.

00:24.520 --> 00:25.630
How many external laws.

00:25.660 --> 00:26.880
One two three.

00:26.890 --> 00:31.910
These are leaf n and this strict binary number of internal laws.

00:31.920 --> 00:37.590
One two three external laws one go three four so four leaf notes are there.

00:37.860 --> 00:44.430
And in this one into the laws one two three four five into the law side five then how many external

00:44.430 --> 00:45.630
laws leaf laws.

00:45.630 --> 00:55.090
One two three four five six six so from these examples we can see that internal laws are to an extent

00:55.090 --> 00:56.090
a lot three.

00:56.230 --> 00:56.880
This is three.

00:56.890 --> 00:58.620
So this is four.

00:59.270 --> 01:01.650
And if it is five then this is six.

01:01.810 --> 01:08.290
So leave no one side one greater than non leave nor for external law side one greater than internal

01:08.290 --> 01:08.730
laws.

01:09.070 --> 01:13.780
So we can come up with the formula EAS equals two ie plus one.

01:14.140 --> 01:21.790
Yes this formula is always true in strict binary trees and in strict but into this formalized more important

01:22.220 --> 01:25.780
there is a number of internal laws plus one as equals for the more fixed in the laws.








WEBVTT

00:00.400 --> 00:08.440
And this topic will learn about what r and r trees and what are strict energy trees just like string

00:08.450 --> 00:09.060
banana trees.

00:09.060 --> 00:16.410
You can also have strict energy trees then height versus moments of strict unaided trees then into the

00:16.410 --> 00:18.510
law enforcers extra landlords.

00:18.520 --> 00:19.820
See here one thing you can observe.

00:19.840 --> 00:20.780
These are energy trees.

00:20.790 --> 00:26.910
But I have given the heading as an early reason and the means of calling the mass number of nodes number

00:26.910 --> 00:30.900
of nodes like in previous videos we have called and asked nodes.

00:30.900 --> 00:32.180
So it may create confusion.

00:32.460 --> 00:35.230
So for a degree I gave the name as Emma.

00:35.460 --> 00:36.800
I'm sorry.

00:36.900 --> 00:45.660
Let us learn what our energy trees really will learn about an early trees and a tree Ennis.

00:45.720 --> 00:52.910
Their degree or for tree degree means every node in a tree can have at most.

00:52.940 --> 00:54.920
And children not more than any children.

00:54.980 --> 00:57.690
Let us take the examples and study.

00:57.740 --> 01:05.120
See here the example is a tree or a tree or tree with a degree 3 so every Lord can have a zero one two

01:05.150 --> 01:07.040
and three children.

01:07.070 --> 01:12.330
Any of these so the capacity of each node is maximum tree.

01:12.500 --> 01:16.340
It can be from 0 to 3 but not more than 3.

01:16.880 --> 01:19.670
So if it is less also you should accept it.

01:19.700 --> 01:21.200
These are my examples.

01:21.230 --> 01:25.310
I have drawn them and seeing that these are all three trees.

01:25.420 --> 01:28.530
All right so I have declared that these are three tree.

01:28.550 --> 01:36.320
So let us check really the odd tree or you're not fussed 1 degree 3 degrees two degrees three degrees

01:36.320 --> 01:37.040
zero zero.

01:37.550 --> 01:38.130
Yes.

01:38.130 --> 01:41.640
No nor is having degrees more than three.

01:41.700 --> 01:43.110
Yes it's perfect.

01:43.920 --> 01:53.980
So 383 what about this degree two degrees three degrees one degrees zero degrees zeroes yes no one order

01:53.990 --> 01:55.860
is having degrees more than three.

01:55.940 --> 02:06.750
Yes it is 383 degree two degrees two degrees zero zero zero no no one is having degrees more than three.

02:07.030 --> 02:08.110
Yes.

02:08.450 --> 02:09.610
383.

02:10.060 --> 02:11.920
It's looking like a binary tree.

02:12.080 --> 02:13.400
Is it not a binary tree.

02:13.640 --> 02:14.010
Yes.

02:14.060 --> 02:21.860
It is also a binary but I said that every law have the capacity to have three children if they have

02:21.860 --> 02:23.440
less than no problem.

02:24.120 --> 02:27.850
But I said that this is 380 for this tree.

02:27.950 --> 02:31.400
So who will decide the degree of a tree by looking at the tree.

02:31.400 --> 02:35.970
We cannot decide the degree great degree of water use of 3D hide it.

02:36.050 --> 02:39.460
So that's what I'm drawing the trees I said that these are three tree.

02:39.590 --> 02:41.780
So based on the condition the tree.

02:42.170 --> 02:44.540
That's so from the tree.

02:44.550 --> 02:47.110
You cannot judge its degree.

02:47.110 --> 02:48.400
Now I have one more example.

02:48.450 --> 02:55.170
Let us look at this for a tree so we know we can have 0 1 2 3 4 children not more than 4 children.

02:55.170 --> 02:57.500
Right now this a tree.

02:57.690 --> 02:59.960
Two children four children two children.

02:59.970 --> 03:01.030
Yes perfect.

03:01.140 --> 03:02.880
Two children three children.

03:02.880 --> 03:03.490
Perfect.

03:03.510 --> 03:05.870
See this also is looking like a tree.

03:06.150 --> 03:12.180
But I just said that every note is having capacity of for and I am drawing it as a four three Eddie

03:12.500 --> 03:13.920
as per the conditions.

03:13.920 --> 03:14.590
Yes.

03:14.650 --> 03:15.510
I just follow it.

03:15.870 --> 03:17.790
What about this fun.

03:17.820 --> 03:19.620
One two three four five.

03:19.650 --> 03:23.620
No n cannot have a degree more than four.

03:23.640 --> 03:25.860
This is not for any tree.

03:25.860 --> 03:26.880
So what does it mean.

03:26.880 --> 03:32.500
I explain you a little bit see if you have the idea.

03:32.500 --> 03:35.090
I'm assuming that you already know this type of thing.

03:35.160 --> 03:40.290
So no structure someone all the value in the year is then not just ignored.

03:40.290 --> 03:44.410
How many children it can have for children it can happen.

03:44.490 --> 03:53.430
So what is the degree of a order it is having four children so all the laws in degree for Villa have

03:53.430 --> 03:56.080
the capacity of having four children.

03:56.130 --> 04:02.270
Suppose this nor does not having all forward this is null then what is that degree offer Nord.

04:02.390 --> 04:03.340
Just a three.

04:03.360 --> 04:09.550
But what is the capacity for if the degree is a three we will not say this.

04:09.600 --> 04:11.350
Is belonging to 383.

04:11.370 --> 04:12.070
No.

04:12.290 --> 04:19.560
See the capacity that is a number that is suppose this node is also not then then is binary not all

04:19.850 --> 04:20.650
based on the law.

04:20.660 --> 04:26.530
We cannot say C the capacity this node belongs to food 3 right.

04:26.600 --> 04:29.560
No doubt and nor does not having all four children.

04:29.570 --> 04:34.530
That's why I said if I'm making a tree then I will decide the degree of a tree.

04:34.580 --> 04:38.100
Next we'll be looking at strict and early trees.

04:38.190 --> 04:47.780
Now strict and tree are strict and every tree is one in which every node can have either zero children

04:48.320 --> 04:51.410
or exactly M children.

04:51.410 --> 04:55.120
For example I have a stick the tree every tree here.

04:55.280 --> 04:57.110
These are some example trees.

04:57.190 --> 05:05.300
Let us check which of these are strict three three trees strictly every means every node can have either

05:05.300 --> 05:08.180
zero children or exactly three children.

05:09.470 --> 05:11.210
Not less not more.

05:11.210 --> 05:14.920
Let us look at the first example degree of this is three.

05:15.260 --> 05:21.120
Okay perfect degree of this is 3 perfect.

05:22.520 --> 05:27.500
So these two whatever degree of this is 0 0 0 degree zero degrees zero.

05:27.590 --> 05:31.010
Yes perfect degrees zero are three right.

05:31.270 --> 05:39.260
So only zero or three only two degrees are allowed degree 3 degrees three degrees three degrees zero

05:39.380 --> 05:39.980
zero.

05:39.980 --> 05:40.820
All these are zero.

05:41.210 --> 05:50.050
Yes this is also strict a 3 3 3 degree 3 perfect degree 0 0 degree 2 wrong.

05:50.060 --> 05:58.190
This is not a stick by any one of the Lord is having a degree too so it's not a strict 3 3 3 degree

05:58.190 --> 06:01.760
3 degree do no wrong.

06:02.060 --> 06:02.810
That's enough.

06:02.810 --> 06:07.740
One notice one letting that condition that I don't have to check the rest of the notes.

06:07.970 --> 06:11.450
So this is not a strict 3 3 3.

06:11.750 --> 06:14.150
So these are the two examples of stick.

06:14.210 --> 06:15.150
3 3 3.







WEBVTT

00:00.760 --> 00:05.510
They will do analysis of height walks us n this type of analysis.

00:05.510 --> 00:10.350
We have already done on binary trees so I will not do much explanation here.

00:10.490 --> 00:12.840
That ugly average I go right on the formula.

00:13.190 --> 00:17.970
We have to get the formula for height versus lords awful strict.

00:18.220 --> 00:24.840
I'm sorry trees right but as an example I have taken a strict the tree every tree.

00:25.100 --> 00:29.350
So from these example trees we will get the formula for a retreat.

00:29.540 --> 00:33.460
Let us look at this sea height of our trees given as a 2.

00:33.560 --> 00:35.990
And these are a minimum number of nodes it can have.

00:35.990 --> 00:40.330
These are maximum n it can have on the height as here 3.

00:40.550 --> 00:42.320
So these are the minimum notes it can have.

00:42.320 --> 00:44.500
These are the maximum notes it can have right.

00:44.510 --> 00:45.570
These are all for naught.

00:45.780 --> 00:47.900
OK so I need the formula.

00:48.080 --> 00:53.990
If height is given minimum home in North the maximum home in n so let us write the formula.

00:54.890 --> 00:59.590
Let us observe and write the formula C high determines how many in the words are there.

00:59.600 --> 01:04.710
Three plus three plus one so three plus three plus one.

01:05.030 --> 01:07.650
It's nothing but two in two three plus one right.

01:07.850 --> 01:12.500
Number of n none here when it is minimum three plus three plus three.

01:12.740 --> 01:20.210
So this is three in good three plus one number of moves are there so it means if if height is given

01:20.210 --> 01:23.030
then minimum laws how many minimum laws are there.

01:23.030 --> 01:31.240
See this three is a degree and two is height three is a degree and three is height here.

01:31.240 --> 01:35.230
So three into each plus one.

01:35.410 --> 01:42.570
So you to hide us into three plus one but actually this a three is degree or four three.

01:42.610 --> 01:49.700
So I should call it as M so I will relay the formula this is M in to each plus one.

01:50.040 --> 01:51.240
Yeah so that's the formula.

01:51.250 --> 02:01.830
So in their strict M A Dream minimum number of N will be n equal to m s plus 1 then the maximum n Harmony.

02:01.900 --> 02:08.040
Let us observe one then three then nine.

02:08.290 --> 02:17.380
What about this one then three then nine then twenty said if I write them this is one and this is three

02:17.680 --> 02:25.960
and this is three square this is three Q So this is one plus the three plus three squared plus three

02:25.960 --> 02:26.650
cube.

02:27.010 --> 02:31.350
So these are the downfall for G.P.S. D Yes but what is this.

02:31.350 --> 02:41.710
Three three is degree M Sibel read I would like this one plus M Plus M squared plus MQ plus goes on

02:41.890 --> 02:43.690
up to whatever the heights.

02:43.810 --> 02:50.650
So this GP series if I add then if you remember the formula for the GP series I laid on the Formula

02:51.610 --> 02:57.650
E R Beauvoir key plus one minus one by R minus one is the formula.

02:58.010 --> 03:04.040
So for this series what is the formula is what here E is 1.

03:04.060 --> 03:13.630
Okay don't write it down on common ratio is what m power K is what H plus 1 minus 1.

03:13.630 --> 03:19.210
So empower x plus 1 minus 1 divided by m minus 1.

03:19.240 --> 03:27.710
This is m minus 1 Yes this is the formula C once again I tell you maximum how many notes possible in

03:27.710 --> 03:35.970
a strict the 383 the total number of notes are forming a G.P.S. this formula this is 4 degree 3 I converted

03:35.970 --> 03:43.170
include degrees M then this the formula for some of the tones of G.P.S. this this is the GP these then

03:43.170 --> 03:49.080
using the formula I have added this one I got a formula for this one so impoverished plus one minus

03:49.080 --> 03:50.860
one by and minus one.

03:50.940 --> 03:59.400
So the maximum loads on maximum laws are n equal to import X plus one minus one by and minus one.

03:59.700 --> 04:01.530
So that's all we got the forum last.

04:01.860 --> 04:08.770
If you already know the height then the minimum how many laws maximum how many n no the other formula

04:08.790 --> 04:15.990
we have to write on if we know that the models n then the minimum height and maximum height.

04:15.990 --> 04:25.080
This was a minimum n Maximum n so I relied on for height safe and laws are given then what is the minimum

04:25.080 --> 04:26.670
height and maximum height.

04:26.760 --> 04:33.600
These formulas I can get them from here like the minimum n can give me maximum height formula C here

04:33.600 --> 04:44.770
it is an equal to m s plus 1 What is H that one if you sign here and the minus one then M comes in denominator

04:45.380 --> 04:48.680
so this etches equals 2 and the minus one by.

04:48.950 --> 04:55.960
Yes and minus one by M then what about this maximum n a formula gives the minimum height.

04:56.180 --> 05:03.650
So this is having power so definitely this will be in terms of log so you can convert this one do paper

05:03.650 --> 05:11.900
work and convert this I will radically write on the form of other c this the formula log base hem and

05:11.900 --> 05:19.130
into a minus one plus one then and together minus one so if you convert this you get that far.

05:20.300 --> 05:26.420
So these formulas are more helpful when you want to know maximum how many nodes are possible and what

05:26.420 --> 05:32.270
is the minimum height minimum height possible so minimum height you can see that it is logarithmic and

05:32.270 --> 05:34.390
a maximum height as in terms of N.

05:34.970 --> 05:38.440
So this is logarithmic under this linear.

05:38.510 --> 05:45.830
The purpose of all these announces is to know the space and time taken by trees when we really use them

05:46.430 --> 05:49.750
when we use the trees at that time we will use these farm myself.

05:49.760 --> 05:55.700
So right that time I will not discuss I will be discussing how to use them rather than discussing the

05:55.750 --> 05:56.760
formulas.

05:56.900 --> 06:02.820
So we are first analyzing and keeping the formulas ready then we will use them afterwards next.

06:02.820 --> 06:08.190
One more formalized remaining that is number of internal North forces extra numbers.

06:08.280 --> 06:13.200
So I'll take the same example please I will remove this and let us find out number of internal unknown

06:13.230 --> 06:14.580
and extra unknowns.

06:15.140 --> 06:21.890
So from these example trees let us find out into the laws and extend the laws of war are stricter 383

06:21.920 --> 06:29.460
than we will prepare the forum for any retreat let us observe how many and on a normal Sunday one 2

06:29.950 --> 06:33.630
internal Lord side do external laws 1 2 3 4 5

06:36.730 --> 06:37.590
the Lords.

06:37.630 --> 06:40.970
One two three four four action Lords.

06:40.960 --> 06:43.080
One two three four five six seven eight nine

06:45.960 --> 06:46.900
into the Lords.

06:46.900 --> 06:56.810
One two three extend lords three four five six seven then into the Lords here.

06:56.810 --> 07:04.720
One two three four five six seven eight nine ten eleven twelve put in external lords these are three

07:04.720 --> 07:11.920
ball with three that is twenty seven so can you find any pattern on the relationship between the values.

07:11.960 --> 07:16.770
Let me check two and five two the two plus one.

07:16.790 --> 07:17.370
Okay.

07:17.420 --> 07:23.980
Doing good two plus one gives me five then four into two plus one.

07:24.090 --> 07:26.550
I would write two into four plus one.

07:26.550 --> 07:28.030
Yes that is nine.

07:28.260 --> 07:29.130
Then what about this.

07:29.130 --> 07:35.400
Two three six plus one seven years Two into three plus one gets a seven.

07:35.400 --> 07:38.660
What does this do in the 13 x plus one.

07:38.670 --> 07:40.550
Yes two input 13.

07:40.590 --> 07:44.030
That is 26 plus one gets twenty seven.

07:44.100 --> 07:53.430
So it means external laws are equal to doing a number of internal laws plus one four are stricter 383

07:54.120 --> 07:58.680
then forward strict and arbitrary ease equals to see.

07:58.700 --> 07:59.670
This was a three.

07:59.670 --> 08:09.390
So I go to two so for em it will be a minus one input a plus one yes this formalise for internal law

08:09.400 --> 08:14.670
enforcers external laws that are for any strict and retrain.


WEBVTT

00:00.300 --> 00:04.080
Another topic is a representation of binary tree.

00:04.500 --> 00:08.010
There are good representation what is already presentation.

00:08.010 --> 00:11.160
And second one is linked to representation.

00:11.160 --> 00:13.290
Let us start with a representation.

00:13.320 --> 00:16.440
Let us look at any presentation of a binary tree.

00:17.460 --> 00:19.260
I have an example by nearly three here.

00:19.260 --> 00:23.130
Labels are alphabet so that's easy for you to understand.

00:23.130 --> 00:29.670
Also I have an update on one thing is read index is starting from an onwards but in C C++ are reading

00:29.670 --> 00:35.670
this and start from zero onwards four for storing in C C++ we can ignore the index zero if at all you

00:35.670 --> 00:37.950
want to use that also we will see it afterwards.

00:37.950 --> 00:45.710
So right now array index of stock from 1 onwards know how to store this by 93 for storing a binary tree.

00:45.780 --> 00:47.750
I have two stored two things.

00:47.760 --> 00:57.030
First one is all the elements that is A2 G and the relationship between those elements like a parent

00:57.030 --> 01:03.800
of BMC or being the left child of a series of HELOC likewise B and C are also having their children.

01:03.840 --> 01:10.790
So if we are maintaining parent and child relationship then we can produce Audrey back again for just

01:10.790 --> 01:12.900
restoring the elements will not be sufficient.

01:13.320 --> 01:20.650
We should also preserve the relationship how I can do this elements I can store them in these spaces.

01:20.780 --> 01:24.270
Yes it's OK but how to maintain the relationship.

01:24.270 --> 01:26.700
Maybe this in this may help me.

01:26.760 --> 01:30.750
They next of each location can help me to preserve the relationship.

01:31.650 --> 01:35.180
Yes I will use that how I will assure you.

01:35.190 --> 01:37.620
So first of all I will feel the elements.

01:37.620 --> 01:40.180
Then I will show you how they are maintaining the relationship.

01:40.200 --> 01:42.440
I will store these elements level by eleven.

01:42.510 --> 01:44.580
So the first level element is E.

01:45.090 --> 01:46.070
The next level.

01:46.110 --> 01:47.690
Second Level B and C.

01:47.730 --> 01:57.960
So given store B and C the third level D E F G so B E F G I have stored all elements.

01:58.230 --> 02:05.070
Now I have to see that other relationships are preserved or not let us observe the NDIS here I will

02:05.070 --> 02:06.690
prepare the table of indices.

02:06.710 --> 02:14.890
With that you can understand C the first element is a a what is the index of this element 1 then who

02:14.910 --> 02:17.330
is the left change of a b there is B.

02:17.400 --> 02:19.490
I could do that too.

02:19.680 --> 02:23.970
Then who is the brainchild of a C so what is the index of c 3.

02:24.120 --> 02:33.560
So I tried to mix history then mixed I think element B what is the index of B to left and right change.

02:33.590 --> 02:45.790
D E Vedas a D for and right j e is at 5 the latest big c c it is an index a 3 here the index of this

02:45.790 --> 02:56.050
element then who's the left shade of C S Veritas 6 then who is the ratio of C G Veritas at 7 so I think

02:56.050 --> 03:02.470
this is sufficient to understand how the relationships are maintained with the help of indices see one

03:02.800 --> 03:09.470
element is at index one damage left Charles at 2 and a Charlie that 3 if the element is that index it

03:09.470 --> 03:21.460
to the left shoulder is that 4 and right change 5 so 2 into 2 right 4 so 2 into 2 plus 1 5 2 3s 6 2

03:21.460 --> 03:29.680
3s plus 1 7 4 Yes this is the formula maintain if any element is at index i then its left child is at

03:29.800 --> 03:34.840
index a two way and right child it is that index to a plus one.

03:35.440 --> 03:39.370
So elements are stored based on this forum alone right.

03:39.790 --> 03:53.430
If any element is at index i done it's left child is at index 2 y then right child is at index 2 Why

03:53.440 --> 03:54.160
plus 1.

03:54.670 --> 04:03.090
So these are the forum let's use not one more thing if I take any element then red as its parent like

04:03.090 --> 04:12.790
for example as who is the parent of F C so f is that 6 sees that three so when this left child we are

04:12.790 --> 04:14.860
getting it by multiplying by 2.

04:14.980 --> 04:17.920
So parent we really get it by dividing it by two.

04:18.010 --> 04:26.760
So the parent of any node will be at I by 2 when you divide any number by goal you may get the decimal.

04:26.800 --> 04:27.970
So shall we take it or not.

04:27.970 --> 04:29.160
Let us check.

04:29.290 --> 04:34.080
G is the child of C GS at 7.

04:34.240 --> 04:36.710
Where is its parent at the 3.

04:36.730 --> 04:40.210
So this is 7 by 2 as the three point five.

04:40.450 --> 04:42.710
So we should take the floor value that is 3.

04:42.880 --> 04:44.970
So yes this is fluid of.

04:45.440 --> 04:51.790
So for any Nord these formulas will help us to obtain its left child.

04:51.840 --> 04:53.560
Child or panicked.

04:53.630 --> 04:54.260
No.

04:54.820 --> 04:58.420
When I was filling these elements I did not follow this formula.

04:58.960 --> 05:06.160
I just fill them level by level and automatically those formulas are applied yes.

05:06.250 --> 05:13.190
So for filling it either you follow the formula or fill them level of 11 automatically the form of be

05:13.210 --> 05:14.760
followed but that's it.

05:14.800 --> 05:16.720
This is not any presentation of binary.

05:17.040 --> 05:19.290
Now I will take a few more special cases.






WEBVTT

00:01.170 --> 00:08.270
No let us look at limited representation offered binary tree so the same example by military I have

00:08.270 --> 00:14.410
taken no linked representation means we will be using norms like norms of linked list.

00:14.420 --> 00:21.060
So yes we will use a northern order structure will be containing data and two pointers left challenge

00:21.100 --> 00:21.770
right chain.

00:22.160 --> 00:29.960
So this no structure is same as the Lord of double dealing the list and W linguists will have previous

00:29.960 --> 00:31.220
pointer and next pointer.

00:31.220 --> 00:33.810
Here we are taking left child on right.

00:33.810 --> 00:41.050
Check this mode can be defined using self-referential structure node having two pointers.

00:41.130 --> 00:47.180
Is a self-referential pointer l child and right child and in-between data is also there.

00:47.960 --> 00:53.030
So we say link the representation we don't say link the list to representation list means it is lenient

00:53.450 --> 00:55.750
but a tree is a nonlinear data structure.

00:56.390 --> 01:03.140
So no next let us see how we can utilize these nodes and represent this one.

01:03.200 --> 01:11.310
So for every node in a binary tree we will create this structure node so I have kept the structure ready

01:11.310 --> 01:12.420
for this tree.

01:12.480 --> 01:20.940
So this is a node for E and this is B C D E F and G.

01:20.990 --> 01:27.330
This is having two children b and c B's having two children and C is also having two children waterboard

01:27.330 --> 01:27.710
B.

01:27.720 --> 01:30.650
There are no children for the there are no children for E.

01:31.720 --> 01:33.250
Okay so these are all known.

01:34.600 --> 01:36.750
So if there is no child I have made it as not.

01:37.500 --> 01:43.820
So this a structure will be dynamically creating so it will be definitely created in heap whereas at

01:43.820 --> 01:50.460
any presentation they can be created in a stack also a heap also so it can be static as well as dynamic.

01:50.460 --> 01:52.690
But this this structure is definitely dynamic.

01:52.800 --> 01:57.600
So this created and heap now let us study something about this one.

01:58.870 --> 02:05.220
There are N nodes and nodes are 7 or 8 because these are 7 nodes in this graphic country.

02:05.230 --> 02:14.410
So here also in the link representation we have 7 nodes that harmony in those pointers are their 1 2

02:14.440 --> 02:16.560
3 4 5 6 7 8.

02:17.630 --> 02:29.450
When there are 7 Lords there are eight null pointers and plus 1 null and the final point is always for

02:29.570 --> 02:34.590
any share of the binary tree you represented using LINQ representation.

02:34.630 --> 02:40.240
Then if there are unknowns then definitely there will be endless one null pointers.

02:41.470 --> 02:43.240
So if you remember this forum alone.

02:43.240 --> 02:45.540
That is if n n then and plus 1 no point.

02:45.580 --> 02:49.460
This is similar to ease equals to a plus one.

02:49.510 --> 02:56.650
This we have studied in strict the binary tree strict bank we studied that number often external unlawful

02:56.710 --> 02:58.520
means and then lords plus one.

02:58.590 --> 03:02.660
So a similar formula if and more so than N plus one another.

03:03.000 --> 03:07.760
I remove one Norn and show you if I am removing this node then this should mean.

03:09.030 --> 03:10.080
How many nodes are there.

03:10.080 --> 03:12.050
One two three four five six.

03:12.060 --> 03:13.800
How many null pointer father.

03:13.800 --> 03:16.310
One two three four five six seven.

03:16.530 --> 03:18.980
Yes seven all point aside.

03:19.290 --> 03:21.850
So that's all about link representation.

03:21.880 --> 03:28.860
Mostly we'll be using this representation for writing programs or algorithms or whatever binary tree.







WEBVTT

00:00.780 --> 00:05.910
In this video we learn about the full blown and complete violently and also see the difference between

00:05.910 --> 00:06.480
them.

00:06.480 --> 00:07.810
The concept is very simple.

00:07.820 --> 00:09.790
So there you have example trees.

00:09.810 --> 00:11.710
Let us look at them.

00:11.820 --> 00:15.490
This is the full binary tree example of full binary.

00:15.600 --> 00:24.750
What is full why entry a binary tree of height each having maximum number of n is a full binary.

00:24.750 --> 00:27.740
What is the height of this by high defined day.

00:27.750 --> 00:28.800
This is a 0.

00:29.070 --> 00:33.560
And here 1 and 2 2 0 1 2 high just 2.

00:33.810 --> 00:39.870
So how many nodes are there maximum n so maximum loan means getting out of an extra node.

00:40.020 --> 00:41.510
And still the height to be 2.

00:41.560 --> 00:42.200
No.

00:42.240 --> 00:47.880
If I had any node anywhere the height will increase for up to height too.

00:47.910 --> 00:54.590
It is having full nodes that is maximum nodes so are 3 of height.

00:54.600 --> 01:02.680
Each can have how many nodes two part PLUS ONE MINUS ONE nodes so what does each year do.

01:02.730 --> 01:06.450
So if I write a 2 year this is 2 plus 1 minus 1.

01:06.510 --> 01:13.230
This is 8 minus 1 7 1 2 3 4 5 6 7 Yes 7 nodes.

01:13.680 --> 01:20.450
If you remember the formula R3 of high age can have a maximum two bodies PLUS ONE MINUS ONE NUMBER OF

01:20.470 --> 01:20.700
NO.

01:20.700 --> 01:24.630
So yes it is having maximum nodes so it's a full 183.

01:24.810 --> 01:25.440
So that's all.

01:25.440 --> 01:32.970
Does the definition of full by entry I will represent that in an added ABC BFG I have filled them never

01:33.050 --> 01:36.320
a level so it is a stored in an array.

01:36.420 --> 01:40.790
Now we have to understand what is complete binary tree.

01:40.910 --> 01:43.310
Now this concept is important complete by hand.

01:43.330 --> 01:44.460
Listen carefully.

01:45.490 --> 01:49.240
For explaining complete my entry I have taken two examples.

01:49.240 --> 01:50.080
So first one.

01:50.110 --> 01:51.420
This one is complete.

01:51.430 --> 01:53.330
This is not complete.

01:53.470 --> 01:54.070
How.

01:54.070 --> 01:55.370
Let us see.

01:55.390 --> 01:57.430
I will represent that in an Audi.

01:57.640 --> 02:13.790
So first one is a a then b c b c then Next Level D E F blank so can be e f b e f f is the last element.

02:13.830 --> 02:19.510
Let's all the size of the tree is 1 2 6 only right.

02:19.560 --> 02:23.950
1 2 6 only know from first element to last element.

02:23.970 --> 02:27.270
Are there any blank spaces in between.

02:27.270 --> 02:31.430
No there are no blank spaces so this is a complete binary 9.

02:31.470 --> 02:32.460
Define it.

02:32.460 --> 02:40.410
If a binary tree is represented in an array then they should not be any blank spaces in between the

02:40.410 --> 02:41.300
elements.

02:42.290 --> 02:44.780
If there are blank spaces it's not accompanied by a..

02:44.780 --> 02:46.040
There are no blank spaces.

02:46.070 --> 02:47.960
It is a complete ban entry.

02:47.970 --> 02:49.540
Now I have one more example.

02:49.580 --> 02:53.840
Let us store this one then we can see what that is complete or not.

02:53.990 --> 03:01.520
Let us store level believe in E. B C is to N B C D.

03:01.630 --> 03:03.580
Then here there should be an element here.

03:03.580 --> 03:04.510
There should be an element.

03:04.510 --> 03:05.770
These notes are missing.

03:05.830 --> 03:07.490
So these blank blank.

03:07.510 --> 03:10.360
E So b blank blank E.

03:10.780 --> 03:16.870
So I got two blank spaces first element as a last element is e in between those two elements to blank

03:16.870 --> 03:17.740
spaces.

03:17.740 --> 03:19.470
This is not a complete binary.

03:19.510 --> 03:21.240
This is a complete mind.

03:21.770 --> 03:30.010
Neither give a book a definition for a complete binary accompanied by name three of hide each here.

03:30.030 --> 03:38.220
Height is 0 1 2 accompanied by entry of height each will be a full by many to be up to actually minus

03:38.220 --> 03:38.830
1.

03:38.850 --> 03:42.860
Height so h minus 1 height.

03:42.870 --> 03:46.880
If you look at this high Bs then just look at this.

03:46.950 --> 03:48.270
It's a full 93.

03:48.480 --> 03:50.990
Yes I'm in the last level.

03:51.030 --> 03:53.940
The elements will be filled from left to right.

03:53.940 --> 03:59.760
Without skipping any elements left side then the right to the left shoulder the strong finish.

03:59.850 --> 04:00.560
No problem.

04:00.660 --> 04:04.410
Finish as many elements we had we have filled them from left to right.

04:04.410 --> 04:09.110
Without skipping without skipping means I'm not writing this right child but digging left and right

04:09.110 --> 04:09.900
change here.

04:09.930 --> 04:15.090
Suppose this is E and this is f then this is missing.

04:15.090 --> 04:20.940
This is missing so it's not a complete battery for last level the elements was different from left to

04:20.940 --> 04:21.650
right.

04:21.660 --> 04:27.540
Let us look at this up to this height it is full but last level the elements are not freed from left

04:27.540 --> 04:28.420
to right left.

04:28.420 --> 04:31.610
The next one is this one here is missing.

04:31.680 --> 04:38.260
So missing means it's not a complete by victory for this the definition of complete binary.

04:38.320 --> 04:38.820
Why.

04:38.870 --> 04:46.350
Why we need complete bank B C we have loan arrays and also we have use arrays for stock out of the last

04:46.350 --> 04:52.080
queue and every time I was telling you that we should not have blank spaces in between the elements

04:52.110 --> 04:56.460
if any element is deleted we should shift the elements and occupy that place.

04:56.470 --> 04:59.360
How we can have blank spaces in an array.

04:59.490 --> 05:07.480
So if our tree is such a dog you are forced to have blank spaces then it is not suitable for a tree.

05:07.680 --> 05:15.310
So we say it's not a complete binary tree we say complete if it is suitable for a coming back to this.

05:15.330 --> 05:17.890
This is a full binary tree right.

05:17.910 --> 05:20.000
This is a full my new tree.

05:20.130 --> 05:21.150
Is it complete.

05:21.150 --> 05:23.150
Yes it's a complete menagerie.

05:23.150 --> 05:29.370
There are no blank spaces in between the elements so full by nature trees always are completed by that

05:29.370 --> 05:35.980
tree there's a well-known statement but a complete binary tree.

05:36.400 --> 05:37.700
I haven't seen this.

05:37.780 --> 05:40.100
This was e and this was f.

05:40.190 --> 05:49.090
OK back to that but a complete monetary need not be followed by mandatory versus completely unnecessary.

05:49.090 --> 05:56.210
It is full but if it Solomons definitely does complete so that's all the differences between full and

05:56.390 --> 05:57.530
complete by military.


















WEBVTT

00:00.300 --> 00:06.300
The topic is trade travel distance traveler segments of visiting all the elements or visiting all the

00:06.300 --> 00:10.580
nodes if a data structure is linear.

00:10.650 --> 00:13.900
Then we can traverse in two metrics.

00:14.190 --> 00:22.220
First to Last that forward our last two first backlit by the when it is non-linear.

00:22.260 --> 00:24.270
Then what are the possibilities.

00:24.330 --> 00:26.280
So for binary trees.

00:26.730 --> 00:34.250
These are possible traverses preorder in order both starter and level order.

00:34.930 --> 00:36.990
So let us learn about these traveller cells.

00:37.000 --> 00:42.880
So first I will read all their definitions preorder mints visiting the Lord first visiting any Nord

00:43.330 --> 00:51.310
then performing pre on left sub 3 and performing preorder on X right usual usually me read it like this

00:52.210 --> 00:55.140
route we say a route left right.

00:55.690 --> 00:58.830
But this is the perfect definition of preorder.

00:58.830 --> 01:05.690
Then in order drivers some first perform in order drive or so on left the subsidy then visit the node

01:05.950 --> 01:12.040
then performing order drivers on the right substrate then pull started traversal by perform or start

01:12.040 --> 01:13.760
or left some tree lights upgrade.

01:13.840 --> 01:18.360
Then visit a node and loss one level of government.

01:18.420 --> 01:20.380
Visit all the moons level by level.

01:21.130 --> 01:27.480
So here I have example trees of height one that small trees let us see what is the result of these traverse

01:27.480 --> 01:35.030
sets so fossil tree I Riddick pre order of this fun I like and shrunk buddy buddy arguments first route

01:35.180 --> 01:41.080
on a more e then go on its left then go on its right.

01:41.120 --> 01:46.460
So a b c is preorder then what is in order.

01:46.540 --> 02:01.700
Foster left then that node a demonstrate so B A C is in order then for starter first left B then right

02:02.000 --> 02:11.420
C then e this is both starter and the level of the level order for this one will be a next level B C

02:12.080 --> 02:20.180
A B C first level a the next level b c then here I can only do n Douglas Road node on its left child

02:20.300 --> 02:28.760
or little N legacy what will be the result of these traverses first preorder first root a then left

02:28.910 --> 02:41.370
B there is no right limit then in order first left then the root there is no right limit post order

02:42.900 --> 02:54.080
first left then right and there is no right then take root the level order first level a then next level

02:54.080 --> 03:01.460
only B is there B so if you are observing this this in order and will start allow same for that particular

03:01.460 --> 03:07.610
tree because it is not having the right child support and in order of see now what more do I have.

03:07.700 --> 03:13.580
Let us write the pre order first root root then there is no left then right.

03:13.740 --> 03:14.140
Okay.

03:14.150 --> 03:18.680
Target right then in order first left.

03:18.680 --> 03:22.620
There is no left then take root root then right.

03:22.790 --> 03:31.370
B Here in this tree preorder on in order I've seen them both starter first left that there is no left

03:31.460 --> 03:32.420
then go to right.

03:32.570 --> 03:41.210
OK take write then root e then level order level eleven first a second level.

03:41.210 --> 03:43.320
There is no element here only this element is there.

03:43.370 --> 03:50.650
So take B so far these are small examples I have shown you how this traverse cells are so actually you

03:50.650 --> 03:55.840
have a district what is the meaning of these traverses now if the tree is larger if it is bigger than

03:55.840 --> 04:02.840
holidays perform let us look at now for a bigger problem of bigotry let us find our.

04:02.850 --> 04:08.670
And so the travelers that I'm going to show you are based on their definitions of each song.

04:08.700 --> 04:13.710
Then there is a shortcut or easy method for finding the traversal just by looking at a tree.

04:13.710 --> 04:20.460
You contend that so that I will show you how to do that but no let us follow their definition ask what

04:20.460 --> 04:21.400
their definition.

04:21.420 --> 04:24.780
I will show you how to find the travelers some disagrees.

04:24.840 --> 04:30.710
Because we have just not seen our smaller size a tree and that only we were able to find our common

04:30.710 --> 04:35.320
sense so just three notes where their height was two but the height is smaller.

04:35.660 --> 04:40.660
So bring this tree and both smaller sized trees means it's a large problem.

04:40.700 --> 04:43.550
So break the problem into small size problems.

04:43.730 --> 04:44.650
How we can do that.

04:44.660 --> 04:45.940
Let us see.

04:45.950 --> 04:46.940
See this is the root.

04:47.360 --> 04:47.750
Yes.

04:47.750 --> 04:48.890
Root of a tree.

04:49.040 --> 04:50.920
Then this is the main node.

04:50.960 --> 04:54.080
Then this is the left child and right chain left.

04:54.080 --> 04:57.440
Child is not just one node it is having its children also.

04:57.470 --> 05:02.030
So make it either separate some between then.

05:02.030 --> 05:02.510
Right.

05:02.520 --> 05:07.660
Child it's not just a child it is having its own children also if it is having your sworn family.

05:07.700 --> 05:14.920
So if somebody in this family so this is a sub tree and there's also some tree and this is the root

05:14.920 --> 05:15.850
of main tree.

05:15.940 --> 05:20.880
Now some mean if you see that as root left as a single block.

05:20.920 --> 05:21.530
All right.

05:21.640 --> 05:27.160
As a single block then inside that if you see again it's a tree.

05:27.170 --> 05:29.000
So this is based on the definition I'm doing.

05:29.060 --> 05:31.930
Again I'm telling you now let us find out preorder.

05:32.210 --> 05:37.240
First Group E then left child.

05:37.240 --> 05:38.290
This is a tree.

05:38.290 --> 05:38.500
Okay.

05:38.500 --> 05:42.840
Put the bracket later we will see what to do then right.

05:42.880 --> 05:46.230
Child there's not just one child it's a tree substrate.

05:46.510 --> 05:49.440
So you put the bracket will see afterwards.

05:49.510 --> 05:54.130
So this pre order is completed based on this tree.

05:54.130 --> 06:01.030
It is completed and those blanks out then we have to fill them now for this bracket this is a child

06:01.060 --> 06:01.720
right.

06:01.720 --> 06:04.180
What is the pre order for this one tree nodes identically.

06:04.180 --> 06:06.460
We know the answer B the E.

06:07.510 --> 06:07.910
Who.

06:07.930 --> 06:08.940
Left right.

06:08.950 --> 06:12.460
So B the E.

06:13.210 --> 06:14.410
Then what about this one.

06:14.440 --> 06:15.760
This belongs to this.

06:15.790 --> 06:17.880
So does the tree with just three nodes.

06:17.890 --> 06:21.310
So we don't actually know the answer broad left right.

06:21.310 --> 06:23.640
C F G.

06:23.930 --> 06:25.620
That said this is the pre order.

06:25.690 --> 06:30.870
Let me open the brackets and write them a B D E C F G.

06:30.870 --> 06:34.420
This is the pre order for based on their destination I have done it.

06:34.840 --> 06:44.290
So this is the pre order now Nix I'll show in order in order of 4 3 for this route of for this node

06:44.560 --> 06:45.560
first left.

06:45.580 --> 06:48.660
This is not just one Nord it's a sub three.

06:48.730 --> 06:51.690
Okay put the brackets we will see it afterwards.

06:51.910 --> 06:55.730
No parent not better than this route.

06:55.900 --> 06:59.510
Take this node then the right child.

06:59.650 --> 07:06.550
It's not a child it's a sub three will get put the brackets we will see it afterwards so left root right

07:07.030 --> 07:08.810
left root right.

07:08.960 --> 07:12.730
The next syllabus bracket.

07:13.000 --> 07:14.890
In order to have some of the slum.

07:14.890 --> 07:21.170
So there are really Latinos we know that in order traversal that is a b b a left road right.

07:21.490 --> 07:36.930
D b e then in order to have a of the spot that is S C G F C G I'll open the brackets and write it it

07:36.930 --> 07:39.770
is a d b a FC G.

07:39.780 --> 07:46.110
This is the in order let me finish post starter for starters his first left.

07:46.110 --> 07:48.720
This is not just one node then right.

07:48.780 --> 07:51.590
This is not just one node then root.

07:51.710 --> 07:55.540
Okay take a then order what this left.

07:55.890 --> 07:58.770
There are three nodes perform both strata BTB.

07:59.940 --> 08:01.350
So the B.

08:01.500 --> 08:02.700
This is the right child.

08:02.730 --> 08:08.510
Perform both strata on neutrinos are there so SGC FGC.

08:08.740 --> 08:13.650
Open the brackets BTB FGC A.

08:13.890 --> 08:17.550
The last one level by level first.

08:17.660 --> 08:22.440
A then A B C then A D E F G.

08:22.610 --> 08:23.130
That's fine.

08:24.150 --> 08:34.720
So here I am the level order level order is a b c d e f g yes A B C D E F G.

08:34.740 --> 08:39.560
So these traversal as we have seen them based on their definition of a traversal.

08:39.990 --> 08:42.580
So this is the perfect way to understand them.

08:43.440 --> 08:48.810
But if a tree is given and you have to find out what is the traversal if you form to find that assert

08:48.900 --> 08:50.640
using pen and paper.

08:50.640 --> 08:52.720
This is not easy vehicle.

08:53.100 --> 08:58.620
Then there are some simple and easy method several level we look at those mockups so now we will learn

08:58.680 --> 09:01.220
how we can directly tell that traversal of.
















WEBVTT

00:00.330 --> 00:06.500
Now let us look at the easy method for finding the traveler cells of a binary tree.

00:06.520 --> 00:08.450
There are more than one easy method saw.

00:08.470 --> 00:10.620
I will show you first met Maytag.

00:10.840 --> 00:15.880
So I'm going to show for all three terror cells I have to consume three three times.

00:15.880 --> 00:20.290
Let us find preorder up on the street preorder for finding your preorder.

00:20.290 --> 00:22.220
Draw a line at the bottom of a tree.

00:22.330 --> 00:26.520
Then from every note from the left hand side of the North Sea is the left hand side.

00:26.530 --> 00:30.230
This is bottom or the middle and this is the right hand side.

00:30.400 --> 00:37.270
So from left hand side stretch a line and connect to this bottom line from every note you do that.

00:37.660 --> 00:40.990
And these lines should not overlap or intersect.

00:40.990 --> 00:43.630
Need not be a straight line just you connect them.

00:43.690 --> 00:53.590
That's enough connected like this connected connected all loads are connected from left hand side to

00:53.590 --> 00:54.100
this.

00:54.160 --> 01:01.370
Bottom line nor scan this line from left to right and see which ones are connecting this first node

01:01.370 --> 01:02.110
is a.

01:02.290 --> 01:03.010
OK.

01:03.080 --> 01:04.360
The next is B.

01:04.370 --> 01:06.300
This line belongs to be OK.

01:06.350 --> 01:10.550
B then B then this belongs to E.

01:11.480 --> 01:17.120
This belongs to see this belongs to f this belongs to G.

01:17.720 --> 01:20.520
So it's scanned from left to right and take all the elements.

01:20.540 --> 01:22.210
This is the pre order of a tree.

01:24.200 --> 01:25.180
So simple.

01:25.250 --> 01:29.610
Now let us look at in order upon this train in order.

01:29.810 --> 01:37.010
Draw a line at the bottom not from the middle or the bottom of a Nord connect the line to this one connector

01:37.010 --> 01:42.000
line from the middle that is in between left and right chain right.

01:42.590 --> 01:43.610
So there are no left right.

01:43.630 --> 01:44.000
OK.

01:44.030 --> 01:50.270
Draw a line and draw a line scan this line then take the elements which are what are connecting from

01:50.270 --> 01:51.250
left to right.

01:51.290 --> 01:59.720
So first as D then B E A F C G.

01:59.830 --> 02:08.080
This is in order then both starter I guess you have a list of what you have to do.

02:08.080 --> 02:14.730
Yes connect lines from right hand side of a node so from right hand side of the node then the right

02:14.730 --> 02:22.790
hand side right hand side and this right side right side of a note and scan for this line and take the

02:22.790 --> 02:25.500
laws which are connecting from left to right.

02:25.580 --> 02:28.660
B E next.

02:28.730 --> 02:37.050
This is B F G C E C A.

02:37.250 --> 02:38.090
This is post on

02:40.810 --> 02:45.790
for anything you can do this and you can easily find the travels.

02:45.820 --> 02:49.770
Next I will show you one more method simple method for finding travelers since.





WEBVTT

00:00.590 --> 00:04.360
Now second easy metric for finding traversal of trees.

00:04.730 --> 00:07.760
So I have same trees for three different traversal.

00:08.330 --> 00:09.800
Let us find out preorder

00:12.540 --> 00:19.940
preorder first on every note draw a line on the left hand side.

00:19.980 --> 00:23.700
Put a mark on the left hand side for every node No.

00:23.790 --> 00:25.000
Next what.

00:25.140 --> 00:30.120
Start from the top group and go along the boundaries of a tree.

00:32.270 --> 00:37.930
This month we came across a e.

00:38.050 --> 00:40.190
Then go along the boundary.

00:40.270 --> 00:50.230
Don't cross over this one B BS marketing he got these moniker we got then.

00:50.290 --> 00:53.540
Get inside go along the boundary right.

00:53.800 --> 00:55.850
Get into the Gulf and come out.

00:55.960 --> 01:03.600
So E then go inside go inside along the bunker.

01:03.660 --> 01:07.320
See an f

01:11.430 --> 01:11.930
g

01:16.060 --> 01:17.160
finished.

01:17.230 --> 01:19.480
So we started in this direction.

01:19.480 --> 01:23.920
Gone around the boundaries then we have reached till the route back again.

01:23.920 --> 01:31.400
So these are the elements that came across we came across the left hand side miles of these elements.

01:31.450 --> 01:38.890
So this is preorder then Hollywood in order for finding you know the drawing marker at the bottom of

01:38.980 --> 01:44.270
each node bottom or the middle right in between Left and Right.

01:44.310 --> 01:44.670
Right.

01:44.700 --> 01:46.600
See this is in between Left and Right check.

01:50.330 --> 01:53.240
Now do the same thing trace along the bone of for 3.

01:53.240 --> 01:54.300
Start from here.

01:54.380 --> 01:54.910
Right.

01:54.950 --> 01:55.620
Go along.

01:55.620 --> 01:57.410
We did not came across any marks.

01:57.410 --> 01:58.610
Is this the first mark.

01:58.610 --> 01:59.790
So take these.

01:59.990 --> 02:04.100
Then get inside your B then

02:10.700 --> 02:15.360
A then along the boundary.

02:15.670 --> 02:16.150
F

02:19.570 --> 02:33.170
C G and this is in order not exposed startup up on the street every two both strata drivers will not

02:33.170 --> 02:36.780
put a mark on the right hand side of each node right.

02:36.870 --> 02:41.590
Right turn side of each note now do the same thing trace along the boundary

02:44.810 --> 02:46.200
first one D.

02:46.340 --> 02:49.740
So the Post order first one we came across as D.

02:50.110 --> 02:52.590
We can go inside and come out then.

02:52.650 --> 02:59.230
E e b then

03:05.980 --> 03:06.540
G

03:10.460 --> 03:14.480
C then A default does the Post trigger.

03:14.720 --> 03:22.250
So this is one of the easy method not find element hard I will show you where you don't have to do all

03:22.250 --> 03:22.940
these things.

03:22.970 --> 03:24.320
Derek Luke and Dan's.






WEBVTT

00:00.470 --> 00:06.440
Now the tournament head for finding traverses without doing any extra work directly you can tell dancer.

00:06.750 --> 00:11.160
So the easiest method I'm shooting you and you can try this method on all these trees.

00:11.190 --> 00:17.040
I'll be shooting it on one or two examples so does the regular tree that I'm picking in every example.

00:17.040 --> 00:18.200
So I will find out.

00:18.340 --> 00:24.160
Cells on the street for first preorder traversal pre honor.

00:25.080 --> 00:31.210
So start from root and take your finger around this tree right.

00:31.250 --> 00:32.990
Move your finger around the tree.

00:33.140 --> 00:37.730
So first law that we came across as a sea.

00:37.790 --> 00:41.660
This is completely visible for the single finger direction is this right.

00:41.660 --> 00:43.250
So this is completely visible.

00:43.250 --> 00:45.050
Next one is B.

00:45.380 --> 00:48.230
Take it then D.

00:48.720 --> 00:56.110
Dad get inside and not e we are able to point on e s e then get inside.

00:56.180 --> 01:03.160
C Then s then G this is preorder.

01:05.240 --> 01:07.970
So move your finger like this in this direction.

01:07.970 --> 01:13.380
A B B E C F G.

01:13.490 --> 01:14.290
This is pre order.

01:15.200 --> 01:16.880
Then what about in order.

01:20.060 --> 01:21.710
Put your finger here.

01:21.860 --> 01:25.240
So actually you have to dig the bottom right are minimal.

01:26.140 --> 01:27.260
So nor does nothing.

01:27.310 --> 01:29.690
No notice visible look at move it out move it out.

01:31.420 --> 01:32.280
Yeah.

01:32.460 --> 01:41.180
A complete node is in the fix and get to the bottom of this node so this is a B then the B E

01:50.190 --> 01:53.250
C G

01:57.050 --> 02:08.560
so I do it once again B B E A F C G then both started

02:12.960 --> 02:19.560
from the site put a finger like this there is no order visible can move along the boundary move along

02:19.560 --> 02:25.320
the boundary yes the first one we came across as a D I will write them afterwards.

02:25.740 --> 02:28.710
Then came come along the boundary yes.

02:28.860 --> 02:36.570
E D E then the B I'll stop here and write on BBA good D.

02:37.800 --> 02:44.640
E and B continue move along the boundaries.

02:44.980 --> 02:47.340
Yeah the complete load is in focus now.

02:47.520 --> 02:53.720
F G C A

02:56.930 --> 03:03.830
G C A does the Pollstar so you've got all the time or so so it's easy.

03:03.830 --> 03:09.680
Just by looking at the tree you can turn it on so you don't have to draw or mark anything on a tree

03:10.140 --> 03:17.990
right now one important observation I will show you here the first element of preorder and the last

03:17.990 --> 03:23.550
element of course strata will always be seen because Flossie was at root.

03:23.630 --> 03:29.540
And here at last it was actual No let me do it up on one of the tree.

03:29.540 --> 03:35.900
I'll take this one and let us find preorder in order and for starters I will not write on just I will

03:35.900 --> 03:45.940
read out preorder a b c d e f then in order

03:49.110 --> 04:00.030
C B E F B then post starter C

04:02.760 --> 04:08.510
F E B B A.

04:08.530 --> 04:14.680
So this is all you can find a traversal for D also does a student exercise you can find out the premises

04:15.250 --> 04:19.100
so that all with the traversal just using pen and paper we have done it.

04:19.210 --> 04:23.800
Next you'll be writing the program for displaying driver cells of three.






WEBVTT

00:00.300 --> 00:07.440
In this video we will learn how to generate a binary tree using Linked representation.

00:07.470 --> 00:12.870
We have seen two representation Ari and Linda representation so I'll be showing it for linked representation

00:13.010 --> 00:17.070
so for generating a binary we can start generating Nordstrom or root north.

00:17.150 --> 00:18.520
We can create Robonaut.

00:18.930 --> 00:25.330
Then we can create left children right chain but when we are creating a left children right child we

00:25.330 --> 00:31.420
should know whether the left child and Rachel are dead or not like there's a fully buy into your complete

00:31.450 --> 00:34.510
binary in this every node is having both left and right.

00:34.510 --> 00:35.230
Child also.

00:35.640 --> 00:40.150
But here some those are not having left child someone not having the right child.

00:40.600 --> 00:44.060
So first of all we should know that her child is dead on order.

00:44.080 --> 00:51.540
If it is there then we can create and attach it so this is the main thing that we have copied Kim so

00:51.540 --> 00:52.580
we should.

00:52.590 --> 00:54.350
So this is the main thing that we have to take care.

00:54.390 --> 00:57.990
We have to check if the child notice there and then we will create it.

00:58.230 --> 01:01.910
Then one morning we will generate it level abandonment.

01:01.920 --> 01:05.880
So Foster will create rule then even create the laws of first second level.

01:06.030 --> 01:07.990
The third level then fourth level and so on.

01:08.190 --> 01:13.940
So that same procedure we can use it for a full body entry also that we can ask a child is dead or not.

01:13.950 --> 01:21.600
But here we need not ask so I'll show you the procedure how to generate the story in the link representation.

01:21.910 --> 01:28.080
So for generating a tree using link representation we need our cue a structure.

01:28.950 --> 01:33.630
So I'm just drawing a study to show that it's a Q I will take a cue.

01:34.080 --> 01:35.300
So this school will have fun.

01:35.300 --> 01:40.330
Point I the point that all the mechanism you know that is why I don't have to explain you its mechanism

01:40.350 --> 01:43.180
just reveal insert delete element from the cube.

01:43.210 --> 01:44.670
Now let us start the procedure.

01:44.670 --> 01:47.570
The very first steps create route north.

01:47.850 --> 01:52.520
So creative onboard and make route.

01:52.520 --> 01:55.640
Point on back north and insert the value.

01:55.700 --> 01:56.810
Then make this assignment.

01:57.730 --> 01:58.450
So Zoom.

01:58.460 --> 01:59.600
That does it only north.

01:59.610 --> 02:03.940
Now this is the first node and is the only note suppose the address of the smallest two hundred.

02:03.980 --> 02:09.260
So that address inserted in the Q So we need justice.

02:09.270 --> 02:11.080
We don't want land to 5.

02:11.100 --> 02:14.760
We want address of a node inserted here.

02:14.850 --> 02:17.460
So this is the initial work that we have to go.

02:17.940 --> 02:20.450
So once again I repeat take a cue.

02:20.580 --> 02:27.650
Create root node insert that the soft root note in the cube now we are ready for repeating procedure.

02:27.830 --> 02:32.620
So now the steps are repeating steps so if you look at one step one or two steps you can understand

02:32.620 --> 02:33.580
rest.

02:33.800 --> 02:40.850
Let us see what do we have to do decode this address from the Q So 200 and make some temporary pointer

02:40.870 --> 02:48.080
B point on that address piece pointing that standing on that note ask whether it is having left China.

02:48.690 --> 02:50.900
So yes as per the tree that we want to create.

02:51.030 --> 02:53.860
Yes it is having a lift chain your left child is there.

02:53.970 --> 02:58.890
So that will create a new node with the help of temporary pointer and insert the value order with the

02:58.880 --> 03:02.940
value this then set these pointers as num.

03:03.180 --> 03:05.060
Then as this is having left China.

03:05.100 --> 03:08.420
So make this BS left the point on this norm.

03:08.980 --> 03:18.820
I suppose that this of this is to bend then this new node inserted into Q No this its child in circuit

03:20.200 --> 03:27.160
so if China's debt that insider nomics for the same nor to be asked whether this mood having value five

03:27.450 --> 03:29.200
is it having a child or not.

03:29.620 --> 03:32.960
Yes it is having it changed so I asked for the plea that we want to.

03:32.970 --> 03:34.170
That is a very change.

03:34.270 --> 03:34.880
Okay.

03:34.990 --> 03:43.850
Take the temporary point and create a new node and insert that value 6 make these arsenal and the PS

03:43.880 --> 03:44.210
right.

03:44.250 --> 03:46.500
Child point in this one.

03:46.500 --> 03:51.630
Some of the ideas on this notice to 30 that insert that address to today in the queue.

03:53.480 --> 03:54.500
That song.

03:54.650 --> 03:57.280
This has finished one step.

03:57.470 --> 04:00.430
So what was the step I'll just repeat it quickly.

04:00.440 --> 04:04.810
We took the pointer from the cue and make people in there and asked for the lift chairs there or not.

04:04.880 --> 04:11.150
And we created it and inserted setters right showed us a little nod yes created and inserted sentiments.

04:11.180 --> 04:13.160
Same dingleberry beating again and again.

04:14.120 --> 04:17.780
So I would be creating the entirety but before going to the next step.

04:17.840 --> 04:20.060
Just one thing I want to tell you here.

04:20.160 --> 04:25.080
We have to ask that the left child is dead or not if it is there.

04:25.100 --> 04:26.680
Then we create.

04:26.810 --> 04:28.970
Again ask right child is dead or not.

04:28.970 --> 04:30.350
If yes then create.

04:31.280 --> 04:37.640
So instead of asking we can simply take the valuables left China and we can put a marker that if the

04:37.640 --> 04:40.880
value interred is minus one then the child is not there.

04:42.100 --> 04:48.100
If it is other than minus one this let us say positive then the values staff let us continue and create

04:48.190 --> 04:50.440
all the north and other dying guy case.

04:50.740 --> 04:55.400
I would do this quickly because already I have explained you next step.

04:55.440 --> 04:59.860
Take to the next address from the queue that is then and make the point that people end on that.

04:59.860 --> 05:06.220
So this is the note then being here asks What is the value of the left side left side is minus 1.

05:06.240 --> 05:07.180
So it is minus 1.

05:07.180 --> 05:08.590
Don't create anything.

05:08.590 --> 05:10.900
Then take the value off right side.

05:10.900 --> 05:12.010
The value is 9.

05:12.010 --> 05:17.940
So create a new node with the help of ten point thirty then enter the value.

05:17.950 --> 05:19.040
Make business null.

05:19.150 --> 05:20.630
PS right on this one.

05:20.680 --> 05:24.410
Some old ideas of this more this 250 in circle 15 to the cube.

05:25.090 --> 05:31.630
So we have finished with left and right now take out the next letters from the cube that is 2 30 and

05:31.630 --> 05:36.030
the make B point on that note and ask the left side value.

05:36.040 --> 05:37.210
That set of values a 3.

05:37.240 --> 05:44.080
So create a new order with the help of temporary point that B insert the value means disaster no BS

05:44.080 --> 05:45.740
left should point on this one.

05:45.850 --> 05:50.410
Support status of this one is 300 then insert data into the q

05:53.220 --> 05:55.790
then ask the right child right churn is minus 1.

05:55.800 --> 05:58.440
So if the value is minus 1 don't create anything.

05:58.800 --> 06:02.920
So we have finished with left child as a let's write check then next step.

06:03.150 --> 06:06.480
Take our data from the cubicle 50 and make B point on that one.

06:06.480 --> 06:09.910
So this is 250 as the left value is there.

06:10.170 --> 06:11.220
So that is 4.

06:11.280 --> 06:18.000
So create a new order with the help of temporary point t insert the value make these s NUM and make

06:18.000 --> 06:19.810
B's left point on that one.

06:19.950 --> 06:27.490
Suppose that s of this mode is 350 so insert 315 for the cube then as the right chart right.

06:27.480 --> 06:30.200
Shared values there it is true so it is not minus 1.

06:30.210 --> 06:35.310
So take the value and create a new node with the help of community pointer insert the value and make

06:35.310 --> 06:37.440
this as no BS right on this one.

06:37.980 --> 06:46.170
And suppose that addresses 2 7 3 70 then instead data 317 to the Q and continue to go digress from the

06:46.170 --> 06:47.750
Q that is 300.

06:48.180 --> 06:54.570
So make B point on that one also the left child it is minus 1 don't create the not the right child minus

06:54.570 --> 06:59.500
1 don't create because there are no left children Rachel for this fun then take out the next set of

06:59.500 --> 07:02.870
some the q that is 350 and make B point on that one.

07:02.870 --> 07:08.910
Also the left child snot that also the right child minus one not there then move to next.

07:08.970 --> 07:17.560
So take our dad as 370 and make B point on that node 370 also the left child minus 1 is not dead.

07:17.680 --> 07:24.860
Also the 8 year and minus 16 not bit then take all the dust from Q There is nothing in the queue to

07:24.860 --> 07:27.200
became empty so stop.

07:27.230 --> 07:33.680
End of the procedure and we have each other to the tree and heap and this is the road which is holding

07:33.680 --> 07:40.800
the entire tree so we have learned the procedure how good generate a tree with the help of Q not ex

07:40.800 --> 07:46.590
we have to write our function for generating a tree so I went through the program called for generating

07:46.590 --> 07:48.000
this tree with the help of Q.












WEBVTT

00:00.160 --> 00:03.060
So procedure already we have seen for creating a tree.

00:03.210 --> 00:05.420
So now I will write on a function.

00:05.640 --> 00:07.470
I have done a function here create.

00:07.470 --> 00:12.020
I have taken required pointers like a P.A. The pointers that we require.

00:12.540 --> 00:18.630
ANDREW POINTER I assume that it is a global that I have declared a Q Also Q Doug a structure so we have

00:18.630 --> 00:20.680
already learned about the structure so that.

00:20.680 --> 00:27.290
Q And it must be initialized so I'm not writing the code for initializing that Q So I assume that it

00:27.290 --> 00:28.350
is initialized.

00:28.520 --> 00:33.290
One more thing we don't know how many laws will be there so we can determine the size of this.

00:33.290 --> 00:38.290
Q So in stock picking in Q using the array we can go for accusing linguist.

00:38.750 --> 00:43.250
Now let me start writing the code as I have already explained you the very first thing we should do

00:43.250 --> 00:44.560
is create a rule.

00:44.780 --> 00:51.890
So I will write on the code here for creating root so brain death and the root value then scan as the

00:51.890 --> 00:53.890
value of fruit in variable x.

00:53.950 --> 01:00.620
So I'm reading the value not X create download using point the root and fill this value and make these

01:00.620 --> 01:06.680
as none so I'm creating a root and all using my log function and filling the day time that node and

01:06.680 --> 01:07.760
making left and right.

01:07.760 --> 01:14.090
Child of that root as none so I draw zero here for number then I should insert this address of this

01:14.090 --> 01:15.520
route node in Q.

01:15.990 --> 01:23.130
So here NQ root thus is inserted in Q Are they explain that initially descendants 200 to be inserted

01:23.270 --> 01:26.240
you know repeating procedure I have to write on.

01:26.240 --> 01:29.970
That has to be done inside the loop so I can use my loop.

01:30.080 --> 01:33.760
How long that loop should continue until Q is not empty.

01:34.040 --> 01:35.510
If it is empty you should stop.

01:35.570 --> 01:37.770
So I will write on loop here.

01:37.860 --> 01:42.880
Why why not is empty Q for as long as Q is not empty.

01:42.890 --> 01:45.430
Continue when it is empty then stop.

01:45.470 --> 01:48.760
Then on the steps I have to write on inside this one.

01:48.830 --> 01:50.460
So what is the first step.

01:50.500 --> 01:54.310
Take all that as some Q and take it to the point or be like.

01:54.320 --> 01:55.970
Initially we did it like this right.

01:56.150 --> 02:06.500
So B assign D Q So be assigned the Q from Q So take all the value from Q1 take it in bind p so PS pointing

02:06.500 --> 02:14.300
there not being there we should ask the value of left China if it is not minus 1 created the last the

02:14.310 --> 02:20.090
right change if it is not minus 1 created those steps have put right on so I would write on the steps

02:20.090 --> 02:27.280
4 left China print def enter left China scan F. take them out due in variable X here I am taking effect

02:27.300 --> 02:32.440
is not equal to minus one if it is not minus one then you will create an order with the help of team

02:32.450 --> 02:39.000
pretty pointer and into the data and make this as Num and make B's left a point on that one.

02:39.020 --> 02:44.660
And also insert dieters into the Q all these are steps I have to do so I will write on these and steps

02:45.140 --> 02:52.190
so here create a new order with the help of camp pointer set the data in that note said the data in

02:52.190 --> 02:59.090
the north and set the left challenge I challenge 0 set left children each others null then also makes

02:59.100 --> 03:07.550
B's left as a D B's left SD then enter the address of this new law in Q So instead that this of that

03:07.550 --> 03:15.380
new node in Q So NQ that D this all will do for left child see from here.

03:15.440 --> 03:22.090
All these steps are for just left child then same steps I should repeat for right.

03:22.100 --> 03:30.750
Child also but in Def enter right child take the value if it is not equal to minus one then create a

03:30.750 --> 03:38.280
node and this line will change instruct PS l child I should write piece on child all the steps are seen

03:39.210 --> 03:44.430
all the steps I see so there is no space I cannot continue so I should write on all these things once

03:44.440 --> 03:52.970
again for the right child also then close why loop and close that function so those steps will repeat

03:52.980 --> 04:01.080
here I should give people the steps the steps that got inside this block on these steps should be repeated

04:01.080 --> 04:07.170
again for the right channels while I think the program I will complete the cord and I will choice execution

04:07.380 --> 04:11.280
so that's all it is the procedure for generating a tree with the help of Q.















WEBVTT

00:00.360 --> 00:04.530
In this video we look at program for binary tree.

00:04.530 --> 00:12.190
We will create a binary tree and also live in see traverse cells on binary tree so for creating a binary

00:12.190 --> 00:18.250
we need to add a structure where we will be storing the addresses of the nodes so already we have written

00:18.440 --> 00:22.260
C language program for Q Using a tree.

00:22.270 --> 00:26.590
So I will use that same board in my new project so I will copy this.

00:26.620 --> 00:35.090
Does the structure for you and create functions that end Q and recusal for the.

00:35.340 --> 00:38.840
So I will take all these on display.

00:38.870 --> 00:41.200
I don't need a display function.

00:41.420 --> 00:41.710
OK.

00:41.740 --> 00:42.470
This is enough.

00:42.470 --> 00:43.440
I will copy this one.

00:45.880 --> 00:53.820
Then I'll start a new project for freeze new project.

00:53.890 --> 00:59.550
I'll give the name as a tree and it's a C language project.

00:59.680 --> 01:00.760
So yes created

01:05.370 --> 01:06.160
Project.

01:06.320 --> 01:14.530
This created now here I will add a header file where I will write on the functions that are required

01:14.530 --> 01:15.160
for.

01:16.260 --> 01:22.630
So I will see a new and find and let it be a header file.

01:23.410 --> 01:26.310
Yes it's a header file and the header file name.

01:26.320 --> 01:30.020
I will call it does Q so kudos.

01:30.020 --> 01:38.510
I just created an inside this I will paste everything so I have create function and 2 and v2 functions.

01:38.510 --> 01:42.520
These functions are for circular Q so that I can use that at a Circle level.

01:44.030 --> 01:46.550
Then here I need more functions.

01:46.550 --> 01:50.030
I will write on them and that is is empty function.

01:50.030 --> 01:57.800
I will write all it should take a cue as a parameter that is struck Q and A skew on this column of value

01:57.860 --> 02:01.330
it should check if friend is equal to red so.

02:01.440 --> 02:02.870
Dot front.

02:02.900 --> 02:10.250
If it is equal to Q Dot red then it should return whatever the result of the C operator should adopt

02:10.700 --> 02:13.930
it destroyed village and draw otherwise it a little false.

02:14.120 --> 02:21.170
So to secure that level not one important thing is this skew is going to store addresses of three nodes

02:21.290 --> 02:23.180
so not in digit type data.

02:23.570 --> 02:27.560
So here itself I will define a structure for node.

02:27.590 --> 02:31.020
Does that mean or so I can say in order or train or anything.

02:31.130 --> 02:43.430
The members of this once struck node that is elder child and integer data and struck node are child

02:46.050 --> 02:50.520
does a structure for a node I have to modify this Q so that it can store these nodes.

02:50.550 --> 02:54.220
So this is node type of point.

02:54.270 --> 03:02.520
So this is a double point that I should make this point it is for me and this is for or interest type

03:02.520 --> 03:10.830
node is going to store pointer of type n then the SKU structure than here then we are creating an array.

03:10.860 --> 03:20.140
It is not integer type pointer so no that I pointed to a pointer that is still pointer on despondent

03:21.790 --> 03:30.440
then the middle of elements our size and it should have size of node type of pointers.

03:30.460 --> 03:39.620
So it's an array of pointer so that arrays created like this dynamically from heap then NQ function.

03:39.690 --> 03:48.100
I have to modify it element it should insert this nor the type of pointer that you should read on me

03:48.490 --> 03:50.260
nor the type of pointer.

03:50.320 --> 03:57.550
Yes on this X should also be know the type of pointer and it should be initially null.

03:57.670 --> 03:59.500
It's not minus 1 and it's not.

04:00.160 --> 04:08.570
So I have done sufficient changes that are useful for making this u q useful for 3.

04:08.640 --> 04:16.780
Now let us go to the main function now outside the main function I will create a pointer of I Nord as

04:16.780 --> 04:19.660
a global variable so that it can access any of it.

04:19.660 --> 04:25.330
So it's easy for accessing root and root is initially.

04:26.350 --> 04:33.710
Now we will see create function create so I have explained you the same way I will write on the code

04:33.710 --> 04:34.060
here.

04:34.250 --> 04:36.260
So I need node pointers.

04:36.350 --> 04:43.870
So let every pointers like E and E that I was using.

04:43.930 --> 04:51.430
Also I need a variable for reading the data then I should also create a q q data structure to then I

04:51.430 --> 04:58.510
should create a Q So for creating a Q I should send a side so I will dig the sides as handed so that

04:58.510 --> 05:04.660
is sufficient for Q and I should also send you as a parameter that is address.

05:05.050 --> 05:16.200
First thing is I should know what is the value in a root and root value then Kenniff person entirely

05:17.730 --> 05:34.130
the value in the variable x then create a root Nord or assign struck node point Malaak size of struck

05:34.390 --> 05:35.760
node.

05:35.960 --> 05:41.950
An order will be created then roads of data should be set as X and rules.

05:41.990 --> 05:50.320
L child R rules are child assigned null.

05:50.920 --> 06:01.450
So the node is ready then I should insert this group in queue so queue this and you in a queue.

06:01.480 --> 06:07.870
Now as I have shown you I should have a Y loop while not is empty.

06:07.870 --> 06:16.570
Q Does this column of value suggest queue that to a point or B I should Daegu from the Q and A a pointer.

06:16.570 --> 06:22.060
So for every node ignored from the queue I should ask for left child and right child the left child

06:22.060 --> 06:27.750
value and rich nature value if it is not minus one then I should insert it so I will write on that procedure

06:27.790 --> 06:47.630
print have enter left child then scan if person entirely Big Data in X and if X is not equal to minus

06:47.630 --> 06:55.260
one side it said that if it is minus one we assume that the value is not there X is not equal to minus

06:55.260 --> 07:04.230
one then we will create a node we assign I should create alone so that God is here I will copied and

07:04.230 --> 07:16.090
pasted here so the North is created then these data should be set as X and these l child as well as

07:16.360 --> 07:27.490
these odd child should be set as null because this will be inserted as a leaf node then is l child that

07:27.490 --> 07:36.850
is left child should be set as t and also this new node I should inserted in the Q I'm sent to the city

07:36.910 --> 07:43.340
is inserted in the Q nodes as I have done for left child the same thing should be done for the right

07:43.340 --> 07:53.600
child also so copy the school and pasted here not instead of saying left child just see a child and

07:53.600 --> 07:59.020
the right child and disappears right.

07:59.150 --> 08:04.480
Change that solve everything the same.

08:04.530 --> 08:11.550
So this is a little Lindy function for creating a tree Andrew does a global variable so it is accessible

08:11.560 --> 08:15.620
everywhere so I can directly create function.

08:15.650 --> 08:21.930
Now here inside main function I will simply call create function we should create a tree then after

08:21.930 --> 08:28.710
that for displaying I should have a function for pre order traversal and do that I will send route and

08:28.740 --> 08:31.110
I will write a recursive function here.

08:31.110 --> 08:46.810
Void pre order struck Nord star P and if B does the symbol code that we have already seen print f person

08:46.810 --> 08:51.010
die leave some space piece data in the data

08:54.480 --> 09:05.610
then call preorder upon B's left child and call pre order upon these child

09:08.630 --> 09:17.150
Laxalt now of the creation of a tree I'm calling preorder function so Maine is having just two calls

09:17.210 --> 09:25.050
two functions create and preorder and one thing on the top I should include the header file.

09:25.220 --> 09:29.440
That is due Hubert H.

09:29.480 --> 09:33.620
I have included next fall.

09:33.620 --> 09:35.420
Now let us compile on the program

09:38.010 --> 09:42.610
whoops I got an error redefinition of creed.

09:42.810 --> 09:45.730
We have written a function called create for you.

09:45.960 --> 09:48.720
So I will change discrete function does it recreate.

09:48.720 --> 09:53.950
I will call it as Trig create function and inside the main function also I will apologize.

09:53.970 --> 09:55.170
3 Create function.

09:55.200 --> 09:56.930
Now let us run this.

09:57.180 --> 10:00.660
Now the program is running into root so the value is 10.

10:00.720 --> 10:07.540
Not only is it having value left child yes 20 is it having a child yes 30

10:10.540 --> 10:14.730
then and the left child whose left child Oh I missed this one.

10:14.930 --> 10:20.450
I should give a message I'll stop this program and I will show here that is who's left child we want

10:20.450 --> 10:21.680
to find out.

10:22.010 --> 10:26.720
So enter left child off person dial D.

10:26.780 --> 10:33.380
So here I will print a piece of data so that I can know who's left child we are asking and even here

10:33.380 --> 10:40.490
I should make a change when I'm asking for the left child off percentile leave so I can know who's left

10:40.490 --> 10:43.570
children and chance are being asked.

10:43.700 --> 10:45.020
No let us on the program

10:47.570 --> 10:53.930
asking for the root values for old value is 10 the center left child friendly and the right child party

10:53.990 --> 11:01.460
and the left child of 20 that is forty then right child is fifty left child of today's 60s HLS seventy.

11:01.560 --> 11:03.250
Then after that I don't have any norm.

11:03.260 --> 11:04.790
So minus one I'm entering.

11:04.790 --> 11:15.470
So it will not do anything do not treat any is preorder traversal you can see this end 20 40 and 50

11:16.100 --> 11:20.710
30 60 70 these are coming on the right hand side these are coming on left hand side and this route.

11:21.260 --> 11:23.090
So this is the preorder troublesome.

11:23.430 --> 11:24.550
That's it.

11:24.620 --> 11:31.040
So I will include one more function like this for the preorders I will write two more functions and

11:31.130 --> 11:40.530
that is for in order n o starter copy this instead of pre order I will just name it as in order under

11:40.570 --> 11:43.720
spring def should be in between.

11:43.730 --> 11:45.390
So this one

11:48.410 --> 11:53.270
and pasted here nine stuff preorder.

11:53.270 --> 11:55.650
This is in order now.

11:55.680 --> 11:58.920
This is both starter OST

12:01.730 --> 12:07.340
and Def should not be the and this is both start or function.

12:07.520 --> 12:13.450
This is both start our function now then I should bring the value yes

12:16.030 --> 12:27.960
after preorder I'll give a new line and then print strata New Line then this is ost order I will call

12:27.960 --> 12:40.470
the function that is post starter post order all these small passing route now let us run and check

12:42.620 --> 12:45.760
I'll give only a few notes route value is at 10.

12:45.830 --> 12:46.660
OK.

12:46.910 --> 12:54.890
Left child is 20 right child is 30 then after that I don't have any N minus one minus one minus one

12:54.980 --> 13:05.660
minus one C pre order is 10 20 30 and started is thirty thirty and it's perfect so that's all in this

13:05.660 --> 13:12.410
video we have seen how to create a 3D what's quite Lindy because I have to prepare Q Also that is useful

13:12.410 --> 13:15.680
for creation of a tree that's all in this video.














WEBVTT

00:00.330 --> 00:09.900
In this video we will write a program for freeze using C++ for creating the three required data structure

00:09.930 --> 00:10.750
that is skewed.

00:11.370 --> 00:14.460
We have already done that in our C language program.

00:14.670 --> 00:22.540
So here in C++ program also we will use a cue for creating three and in this program I will not be writing

00:22.540 --> 00:27.820
the code once again but I will be copying the code from C language program which we have already seen

00:28.900 --> 00:32.130
because the procedure inside the function will be same.

00:32.260 --> 00:37.480
Only the thing is we have to write C++ class for our.

00:38.920 --> 00:46.310
So I will copy the scored for Q Does a class for Q which we have already implemented in previous videos.

00:46.420 --> 01:03.160
I will use this class in my new project so I will copy this one let's start on new project.

01:03.250 --> 01:06.680
I'll call the project name as a tree CBB.

01:06.760 --> 01:10.210
Let us select the language type as C++

01:13.950 --> 01:18.810
project is ready on here in the project I will insert a new fine.

01:19.160 --> 01:23.870
So I will see a new fine and let to be a header files in this header file.

01:23.870 --> 01:29.020
I'll keep a class for Q If I let us call it us.

01:29.070 --> 01:40.760
Q CPB on this header file is the code that I have copied their so there's a class for Q Yeah here this

01:40.760 --> 01:46.190
class is using still print defence can answer because I did not change them to sign and out so this

01:46.190 --> 01:53.020
class needs a studio on edge so I will include a studio or edge hash include

01:56.730 --> 02:04.230
this Q glass should be using a Nord for Greece so I will define a class for node here self class for

02:04.650 --> 02:11.490
node I'm saying Lord and this note will be for our tree so this node will have three members I'll make

02:11.490 --> 02:19.090
those numbers as public so that I can easily access them first is a pointer to a left child and next

02:19.090 --> 02:21.490
is data that I want to store.

02:22.010 --> 02:25.660
And third one is a pointer to a right child.

02:26.000 --> 02:36.420
So I chided this class as a for node so there's a node of a tree not the skills should work up on no.

02:36.440 --> 02:42.080
So I should modify the code for this norm because I may be storing the addresses of the Nords in the

02:42.080 --> 02:45.080
Q while creating our tree.

02:45.080 --> 02:52.540
So here I will make changes this tree should be of type node pointer so node pointer so already it's

02:52.550 --> 02:59.570
a pointer so double pointer Then here insert the constructor when I am creating an eddy I should not

02:59.570 --> 03:05.930
see an end I should say node pointer and one more leaf I have mentioned this.

03:05.930 --> 03:12.170
This is node point that this Google also should store the addresses of a tree.

03:12.200 --> 03:15.750
So that's why I'm converting into node NQ.

03:15.770 --> 03:19.130
It should not take a integer but a node pointer

03:23.790 --> 03:24.420
here also.

03:24.460 --> 03:26.270
NQ I should change it.

03:26.520 --> 03:32.400
So I'm making required changes and you should return a node pointer

03:35.960 --> 03:44.800
VQ return type is node pointer on this variable where I'm taking the data it should be of note type

03:44.890 --> 03:53.100
and I should initialize it to null does display function Doi don't need it let it be.

03:53.170 --> 03:54.170
I'll just leave it.

03:54.310 --> 03:56.340
I don't have to make any changes in this function.

03:58.860 --> 04:00.450
So that's all I guess.

04:00.450 --> 04:04.570
These are the changes we need in a queue class.

04:04.620 --> 04:06.480
So we have made required changes.

04:06.630 --> 04:10.770
Now let us go back to the main part of a program that is main function.

04:10.770 --> 04:17.910
So here I should write a class for three class for 3 lines like this.

04:17.910 --> 04:24.100
I should have only one day I remember that is a rude pointer to root Nord that is root.

04:24.260 --> 04:27.120
No the question is shall I make it as a public or private.

04:27.240 --> 04:29.400
I may be using it from outside the class.

04:29.400 --> 04:33.960
Also I suggest this should remain as public if it is made as a private.

04:33.960 --> 04:36.630
Then I have to make a lot of changes in the code.

04:36.810 --> 04:41.820
So let us declare that public not inside.

04:41.920 --> 04:50.980
The first thing is constructor so constructor class names tree and nonpayment constructor and just have

04:50.980 --> 04:58.100
to initialize it to null rule does initialized as null null no need of any constructors.

04:58.090 --> 05:00.010
No I will write down the required methods.

05:00.010 --> 05:02.730
First one is create three.

05:02.830 --> 05:09.340
Function which doesn't take any barometer because it does have a level inside three glass itself.

05:12.090 --> 05:16.200
That next function is preorder.

05:16.400 --> 05:17.900
I'll take capital B.

05:20.060 --> 05:22.200
It piece a rude pointer.

05:22.330 --> 05:27.000
So let us call it that's B point and b void OST.

05:27.040 --> 05:30.730
Order.

05:30.850 --> 05:41.270
It also takes a pointer to rule that this let us call it DSP then in order.

05:41.400 --> 05:47.400
The point that s been these functions we have all the data and then the C language program for the same

05:47.400 --> 05:53.890
set of function and making them as member functions of pre class then.

05:54.020 --> 06:03.180
Also I will write on one function for level order level order function and it also takes a pointer to

06:03.630 --> 06:06.720
root and height function

06:09.690 --> 06:12.540
height which takes a splinter group root.

06:14.630 --> 06:17.940
So these are the functions I'm going to implement them outside.

06:17.980 --> 06:20.000
What I said that I loved writing the code.

06:20.000 --> 06:21.720
Once again I learned typing the code.

06:21.740 --> 06:28.320
Once again all these functions I'll copy them from my c language program and is them and use them here.

06:28.370 --> 06:32.210
So let us first bring the function that is created three function.

06:32.300 --> 06:34.900
So already I have that project open here.

06:34.910 --> 06:37.920
So this created three function puppet

06:42.720 --> 06:47.870
first function I will puppet and I will use it here and I'll.

06:47.930 --> 06:49.840
Also I will make all the required changes.

06:49.870 --> 06:52.780
So just watch how I'm making changes in this one.

06:52.940 --> 06:54.680
This is three create function.

06:54.680 --> 06:56.790
Actually I am calling it has created three.

06:56.810 --> 06:58.970
OK change the name.

06:59.090 --> 07:05.280
This is inside three glass and this is create three function.

07:05.560 --> 07:13.880
OK then inside this this is not a structure more so just a node.

07:14.060 --> 07:20.050
I need three pointers then to all of your classes available.

07:20.060 --> 07:22.000
So I have to create an object of queue.

07:22.160 --> 07:25.870
So yes Queue object will be created for this one here on the top.

07:25.880 --> 07:37.390
I should include header file that is include queue CBB dot etch the header file.

07:37.420 --> 07:38.890
Now I can use that queue.

07:39.790 --> 07:43.510
So if you see this header find this dual CPB dot.

07:43.600 --> 07:44.800
This header file.

07:44.860 --> 07:49.440
I have the queue as well as the node structure for our trees as defined here.

07:49.480 --> 07:54.910
All those things I'll be able to use them in my main part of a program when I have included this header

07:54.910 --> 07:55.330
file.

07:57.600 --> 07:59.770
Now line by line let me continue.

07:59.770 --> 08:05.770
Here I was creating a queue of size Hendricks so instead of calling a function create I will just call

08:05.770 --> 08:12.040
parameters constructor of two class so a queue of size hundred will be created and it will be a queue

08:12.040 --> 08:14.520
of pointers of type between.

08:15.340 --> 08:22.510
Then here this goes regular on here instead of seeing my log and size of all those things I have to

08:22.510 --> 08:25.090
simply say new normal.

08:25.540 --> 08:34.330
So I replaced this little code that is new node and that's of the things that as it is.

08:34.510 --> 08:42.730
Then NQ so this is a part of Q No Q Dot and Q and I don't have to parse this as parameter just a rule

08:42.730 --> 08:48.940
does but I mean I see this as a function and use a function inside the class for Q Dot and Q I have

08:48.940 --> 08:54.490
to see on here why not is empty.

08:54.530 --> 08:59.630
Oh I have not implemented is empty function so I will be implementing that is empty function there I'll

08:59.650 --> 09:08.890
do it after Lux is empty function inside a Q glass then Q Dot did Q I should say I should not parse

09:08.890 --> 09:14.910
this anything as a parameter then indefinite let it be as it is no problem in different scanners we'll

09:14.950 --> 09:22.600
be using as this as it is I will not change them so for that I should include a studio your dark edge

09:26.170 --> 09:27.830
I can use print defense scanners.

09:27.860 --> 09:35.720
So this is printing and leaving the value and the value is Wenzel I have the value is minus 1 then don't

09:35.720 --> 09:41.930
insert anything if it is not equal to minus 1 then create a new node so for this I will call it as new

09:41.930 --> 09:52.810
node the node is created all the links are set then all Q Dot and Q Change this one log in and of scan

09:52.810 --> 10:00.200
if everything is as it is then this partial change that is new node

10:08.270 --> 10:09.990
and again here.

10:09.990 --> 10:21.210
Q Dot and Q remove this Q S parameter that's all this function is ready recreate function is really

10:22.140 --> 10:27.600
one thing I have to write on is empty function so I'll go to this class and here I will introduce a

10:27.600 --> 10:32.580
function that is is empty just after the you should read on.

10:32.640 --> 10:36.650
True or false is empty True or false.

10:36.660 --> 10:44.330
So for what what is the condition for Q empty if front is equals to rather then Q is empty it should

10:44.330 --> 10:49.330
be done the result of this condition directly returns front is equal stood there in front is equals

10:49.340 --> 10:50.870
should it returns empty.

10:50.880 --> 10:52.100
Yes true.

10:52.110 --> 10:57.650
So this is sufficient so I have implemented it as an inline function that is within the class itself

10:59.830 --> 11:05.880
not going back to the program C here I have implemented a great read function that I need preorder or

11:05.880 --> 11:13.080
start are in order so I will probably those functions and I'll modify them here according to my CPB

11:13.170 --> 11:21.700
program so here I have those functions preorder in order and for starters copy all these functions

11:30.090 --> 11:36.100
here inside the means part of a program after t create function I will write on those functions all

11:36.100 --> 11:39.690
these three functions I need them pre order.

11:39.760 --> 11:45.600
This is a part of a tree and just not have declared it here inside a class right preorder right.

11:45.610 --> 11:53.290
Same function I'm writing it as a part of a class so I am using scope resolution then what is the change

11:53.290 --> 11:59.110
inside this just print difference of print if I can use a c out let it be print if only so there is

11:59.110 --> 12:05.500
no difference so just it has become a part of our class now then in order also I made it as a part of

12:05.500 --> 12:14.290
3 class then pre or post order also I made it as a part of class normal changes at all C as it is the

12:14.290 --> 12:20.320
code is useful though it was earlier in a C program it was an independent function but now it has become

12:20.320 --> 12:27.860
a part of three class that is the difference here let us bring other functions that is level order function

12:27.980 --> 12:31.460
and hide function

12:37.150 --> 12:38.420
does a level order function

12:42.920 --> 12:48.800
down and height is also there so I'll copy these and paste them here

12:54.080 --> 12:59.430
so only I have not declared I'm not using it as a move this one.

12:59.720 --> 13:06.290
Height and level order therefore hide directly I will chain this one this is height capital H I have

13:06.290 --> 13:09.650
taken and this is a part of three class.

13:09.650 --> 13:17.200
So just say three and here inside this also this is capital edge and capital edge natural no more genius.

13:17.270 --> 13:24.200
Same quarter we look for this class also no let us come to level order for level order I should call

13:24.200 --> 13:31.880
it as a member of three so it's illusion then here inside this again a level order function function

13:32.200 --> 13:39.710
uses a Q So I have to use that Q Plus this class which you have written here inside the header file

13:40.100 --> 13:47.060
this class I have to use so for making use of this one I should make required changes first of all I

13:47.240 --> 13:54.830
take a cue that is the object of Q class and I will take it as a constructor as hundred so I will remove

13:54.830 --> 14:02.360
this one I will not have create function then def is there let the print be as it is then this is and

14:02.690 --> 14:09.170
the Q function that was in C language which was taking Q as well as the value to be inserted but now

14:09.440 --> 14:19.900
it will be a part of Q Plus Q object so say Q Dot Q Dot and root node of any parameter then this is

14:20.320 --> 14:28.950
Q dot is empty don't pass the test parameter then Q Dot indeed Q Is that secured or did you

14:33.650 --> 14:41.950
then as a child our child then the first Q Dot NQ and knowing of this parameter and here also killed

14:41.950 --> 14:46.580
out and Q north of q as parameter next the

14:50.170 --> 14:56.050
now Main function I have to write off the words but here let us come by land Check Are there any errors

14:56.140 --> 14:58.610
if there are any errors I will remove them.

14:58.990 --> 15:04.540
See the approach would have taken here is I have copied the existing code and I have written prepared

15:04.540 --> 15:09.850
a class for three without writing even a single line from the scratch.

15:09.850 --> 15:14.980
So only the class I have written and I have implemented all the things that are borrowed from the existing

15:14.980 --> 15:17.770
code so I may get errors.

15:17.770 --> 15:21.060
So just watch if there are any errors how to remove them.

15:21.280 --> 15:22.240
I'll come by list one

15:25.300 --> 15:26.740
yes there are 4 errors

15:31.330 --> 15:41.380
first one level order c it is not matching here C inside this class I have given small letter or this

15:41.380 --> 15:48.040
is capital letter oh OK I will change it to small letter or let me compile once again and see how many

15:48.040 --> 15:48.750
errors I get.

15:48.770 --> 15:52.390
OK still three errors I mean go this height.

15:52.590 --> 15:54.910
OK for height I got an error.

15:54.910 --> 16:00.970
So height actually it is returning integer type so it is giving an error that return type of outline

16:00.970 --> 16:01.900
function is different.

16:01.900 --> 16:05.560
So let us go back to the class definition and see 0 height.

16:05.590 --> 16:07.970
I have written it as void.

16:08.020 --> 16:09.370
So it should be an integer.

16:09.370 --> 16:11.210
It will be anything in height.

16:11.240 --> 16:12.640
I'll compile it once again

16:15.450 --> 16:21.580
successful and I will write on a main function inside a mean function.

16:21.690 --> 16:25.130
Let us create a tree and all traversal functions.

16:25.170 --> 16:28.660
So tree e is a tree.

16:28.800 --> 16:31.470
Now on three I will call function

16:34.080 --> 16:40.100
create tree let us check the function yes create a tree.

16:40.100 --> 16:43.510
This function I'm calling which will create a tree.

16:43.820 --> 16:46.940
Then after this I will call just pre order function

16:50.170 --> 16:55.060
not just preorder I should pass a rule and deposit setting as a function.

16:55.060 --> 16:58.930
Definitely need some that I mean that it cannot be vetoed.

16:59.010 --> 17:07.010
I mean that so I should pass the DOT through e dot root rule dessert date a member of a class A tree

17:07.050 --> 17:13.880
yes there's a date a member can access this yes it is kept in public that is the reason I have made

17:13.880 --> 17:16.790
it as public so that I can access it directly.

17:17.630 --> 17:24.230
Otherwise I cannot write recursive function directly I need some dummy functions which will call these

17:24.230 --> 17:26.720
functions indirectly I'll show you that one

17:30.560 --> 17:37.140
in Ireland if I don't make it as a public then they cannot call these functions that are recursive function

17:37.170 --> 17:45.150
directly for them I need some other dummy functions I will show you how to do that later I'll show you

17:45.150 --> 17:46.740
how to make this as private.

17:47.610 --> 17:49.680
So let us go to this

17:53.040 --> 17:55.990
main function and complete it.

17:56.080 --> 18:01.740
Yes I'm calling preorder now let us run the program and see I will create a tree and it should perform

18:01.740 --> 18:02.670
preorder on it.

18:08.210 --> 18:08.960
Yes.

18:09.200 --> 18:16.760
Running it's asking the root value what value add is that as a end left child of ten is twenty.

18:16.790 --> 18:20.240
Rachel of ten is thirty and there are no more children

18:23.150 --> 18:32.280
yes I got a preorder and Brandy thirty is a preorder it's working let us perform in order also and check

18:36.060 --> 18:36.620
eat.

18:36.760 --> 18:37.430
Root.

18:37.670 --> 18:40.490
I will pass it as part of me to run it.

18:43.670 --> 18:49.720
Program's running it's asking for the root value as a 10 and the left child is 20 right and is 30 and

18:49.720 --> 18:52.100
no more children beyond this

18:55.340 --> 18:55.750
yes.

18:55.750 --> 19:02.960
Does the preorder end 2013 is a preorder and only 10 party is in order.

19:02.960 --> 19:05.690
So let us make it properly.

19:05.690 --> 19:09.130
Let me give a proper labelling here before this preorder.

19:09.200 --> 19:12.430
I will give a message that this is preorder

19:15.930 --> 19:17.670
preorder with a gap.

19:17.670 --> 19:29.720
Then after preorder also I will give a new line and then after this I will say in order in order.

19:29.920 --> 19:37.150
Then with the gap then after in order again I will give a new line seal and all that is new line one

19:37.150 --> 19:45.430
more new line is then what I am using C out here I should use using namespace I should declare in the

19:45.430 --> 19:45.830
beginning.

19:45.840 --> 19:47.170
Already you have done it.

19:47.230 --> 19:48.340
Let us run the program.

19:53.060 --> 19:58.090
Now enter the values the value is 10 and its Left child it's 20 right and it's 30.

19:58.300 --> 20:01.770
And no more children.

20:01.990 --> 20:03.490
Here you can read it.

20:03.490 --> 20:07.030
That is preorder is an Indian 30.

20:07.180 --> 20:09.100
And in order it is 2010.

20:09.120 --> 20:09.620
Party.

20:09.710 --> 20:11.230
Yes it's working.

20:12.130 --> 20:12.830
Their song.

20:13.440 --> 20:18.880
No I just said that I can't even make this route as a private so that it's accessible only inside the

20:18.880 --> 20:21.480
closet then how could I do this recursive function.

20:21.490 --> 20:23.230
How we can parse the parameter.

20:23.230 --> 20:31.360
So for this I should have one more reorder function that is our barometer and it should all this preorder

20:31.360 --> 20:37.850
function bypassing a root as a parameter.

20:37.860 --> 20:43.740
Now let us call this function reorder functions you can see that this non-payment Rice function and

20:43.740 --> 20:44.720
this is paramount right.

20:44.730 --> 20:46.770
So does our overloaded function.

20:46.770 --> 20:48.780
So from this function I am calling.

20:48.780 --> 20:51.350
Second one this function by passing a rule.

20:52.330 --> 20:57.450
So from the main function I cannot pass rule so I will pull this function and this will call recursive

20:57.450 --> 20:58.730
function by passing rule.

20:59.220 --> 21:07.870
So let us call this preorder function from here and check I'm not passing a rule as parameter.

21:07.940 --> 21:09.860
Now let us run it will look

21:12.970 --> 21:14.800
yes it is working.

21:14.920 --> 21:24.250
So if I give the values 10 20 and 30 then minus one minus one minus one minus 1 x Working preorder is

21:24.250 --> 21:25.000
executed.

21:25.210 --> 21:27.490
So the same function has executed.

21:27.520 --> 21:33.070
So if you check here I'm calling the first function that is without any parameters and that function

21:33.070 --> 21:34.930
is calling a function parameter.

21:34.930 --> 21:41.500
So in the same way for all these function I should provide a dummy function which without making any

21:41.500 --> 21:49.560
parameters then I can make this rule as private so I will write down no laws and I will show you finally.

21:50.890 --> 21:57.310
Yes I have written a dummy function for each and every recursive function so these w functions are calling

21:57.310 --> 21:59.200
both recursive function internally.

21:59.410 --> 22:01.420
I can make this as a private.

22:01.450 --> 22:04.480
Now this rube I can make it as private

22:07.510 --> 22:10.210
so I'll just declare it above public.

22:10.300 --> 22:11.580
So it becomes a private.

22:11.620 --> 22:18.250
From here I don't have to call function by passing rude directly I can call the function a dummy function

22:18.260 --> 22:18.940
will be caught.

22:18.950 --> 22:23.600
That in turn will call function that is recursive function.

22:23.690 --> 22:26.130
So for all of them I have given dummy functions.

22:26.210 --> 22:28.180
Now I'm able to make it as private.

22:28.190 --> 22:29.560
This is the approach you have to take.

22:31.150 --> 22:33.370
If I run it unsuccessfully

22:36.630 --> 22:38.920
I learn to give the values and already we have seen it.

22:39.240 --> 22:42.190
So that's all in this program.

22:44.770 --> 22:52.010
Oh there is some warning at issuing some warning that check the warning.

22:52.010 --> 22:57.230
OK here it is giving a format specified error.

22:57.590 --> 23:01.920
Yeah we are displaying addresses here but it is a d written here anyway.

23:01.940 --> 23:04.430
This display function we are not using it.

23:04.520 --> 23:05.740
We don't need it.

23:05.960 --> 23:08.560
So let us ignore it.

23:08.810 --> 23:10.250
That's all in this program.

23:10.250 --> 23:17.650
So you have seen how we can write C++ class for our tree so you can write on this by yourself.

23:17.660 --> 23:23.840
If you have implemented both functions you can bottle them here and you can avoid being the whole program

23:23.840 --> 23:24.440
once again.

23:24.440 --> 23:28.790
So that is the reason I'm having brain scan if as it is used here.

23:28.790 --> 23:34.300
You can change them to scene and see our cultural so that's all in this video.













WEBVTT

00:00.690 --> 00:07.680
In this video we look at the recursive function for pre traverse cells that are preordered in order

00:07.680 --> 00:11.390
and both startup already I have an example already.

00:11.720 --> 00:19.910
Let us start with the preorder for traversal so I have taken an example three with the lingering presentation.

00:20.000 --> 00:25.620
These are the nodes with the data inside the node and this is the address of Norb below each node it's

00:25.850 --> 00:26.980
necessary.

00:26.990 --> 00:33.680
This is a recursive function for preorder traversal so let us read the function then I will show how

00:33.680 --> 00:37.160
this function and find out preorder on this tree.

00:37.250 --> 00:42.830
C function is taking a parameter that is rude of our tree so we will pass through the document.

00:42.830 --> 00:49.010
Suppose if you're calling then we call it as pre order root so we'll pass the address of the group.

00:49.100 --> 00:50.690
That is 200 to this one.

00:50.750 --> 00:55.730
So here the parameter name is deep inside the function it will check if these NOT NULL.

00:56.250 --> 01:02.170
So there is some node if there is some law then it will perform three steps into the data from that

01:02.190 --> 01:08.330
node second step call itself recursively upon left chime.

01:09.660 --> 01:13.940
Third step call itself recursively upon great change.

01:14.520 --> 01:19.410
So these are the three steps it will perform as it is recursive.

01:19.410 --> 01:25.640
It will call itself again and again until and dietary is a tri worst in preordered Travis.

01:25.800 --> 01:28.110
We already know how or goes to function works.

01:28.110 --> 01:29.510
We have seen their tracing.

01:29.520 --> 01:36.540
We have generated the tracing tree and we also know that stack is used by a recursive function for each

01:36.540 --> 01:37.440
call activation.

01:37.430 --> 01:44.370
The cards are created in the system stack so similarly let us a trace of this preorder function up on

01:44.370 --> 01:45.050
the street.

01:45.330 --> 01:50.670
So let us generator tracing three so far tracing three I ever take stock also.

01:50.820 --> 01:56.610
So here I will create a stack that is system stock to show how deactivation the cards are created for

01:56.610 --> 01:57.110
each card.

01:58.210 --> 02:03.760
Let us start tracing that function using tracing train first time and the function is scarred by passing

02:03.760 --> 02:12.270
rule Bruges dieters of the first note that is 200 render the function is with the address 200 pre 200.

02:12.280 --> 02:14.110
In short I'm writing just breathe.

02:14.320 --> 02:22.510
First call B are 200 so as low as 200 200 is passed for one the function is card an activation the card

02:22.510 --> 02:28.000
is created activation of the card will contain all the variables that are used by that function.

02:28.180 --> 02:31.900
So what are the variables using a function only D use.

02:31.900 --> 02:38.300
So that is viscous so light on just add a stool and that activation the card will be created where devalue

02:38.310 --> 02:39.040
the student.

02:39.970 --> 02:43.020
Then let us execute first a statement d not no.

02:43.330 --> 02:48.250
Yes 200 is not going it is not null then perform three steps.

02:48.250 --> 02:52.370
So three steps faster step S Printer data.

02:52.390 --> 03:01.000
Printed data of the small eight then second step call itself again on left Child Left children of this

03:01.070 --> 03:04.330
210 colored self again on 210.

03:04.570 --> 03:08.260
Then this third step call itself again on the right chain.

03:08.320 --> 03:09.460
We will do it afterwards.

03:09.460 --> 03:11.410
First let us finish this fight.

03:11.800 --> 03:13.190
So this gone.

03:13.240 --> 03:16.510
What happens again an activation the card is created.

03:16.870 --> 03:20.290
But the key value is to them before continuing.

03:20.290 --> 03:23.120
Let me write on the output that we got so far.

03:23.260 --> 03:28.160
Value a just printed value aid is printed now for this gone to.

03:28.180 --> 03:30.720
Then let us start the procedure once again.

03:30.750 --> 03:31.550
Bhutan is not.

03:31.560 --> 03:31.780
No.

03:31.870 --> 03:33.100
Yes not no.

03:33.190 --> 03:34.100
Three steps.

03:34.100 --> 03:34.630
Print.

03:34.640 --> 03:38.390
Call on left call on the right in the data.

03:38.510 --> 03:45.350
So Gordon values 3 that call itself again upon left child.

03:45.470 --> 03:50.840
That is to 70 God itself towards step upon the right child.

03:50.900 --> 03:51.910
We will do it afterwards.

03:51.930 --> 03:53.920
First of all this has to finish.

03:54.120 --> 03:57.290
Now for this call activation the card is created.

03:57.300 --> 03:59.270
This is 270.

03:59.430 --> 04:02.510
For this 270 and the function is card again.

04:02.510 --> 04:03.770
Again this is not not.

04:03.810 --> 04:08.190
Yes it is 278 is not performed three steps so three steps.

04:08.190 --> 04:12.430
We know this step very will no longer be checking every time here we know the steps.

04:12.630 --> 04:13.680
Call up on left side.

04:13.680 --> 04:14.600
Call upon the right side.

04:15.000 --> 04:17.440
I will be following these three steps every time.

04:18.090 --> 04:20.040
So now this is not normal.

04:20.340 --> 04:27.610
So bring the value for God itself upon left child what is left child null.

04:27.660 --> 04:31.240
This is not the sound writing be here for preorder.

04:31.700 --> 04:39.030
Then again Activision record created Vita No not this time these not none.

04:39.030 --> 04:40.200
Not only does none.

04:40.380 --> 04:43.340
So it will not enter into this if an end.

04:43.560 --> 04:49.740
So this function terminates without doing anything so is activation that caused us to do it at once

04:49.740 --> 04:55.590
this is deleted it will go back to the previous function call the previous function call was to 70 in

04:55.590 --> 05:03.240
that function call out of three steps those steps are completed printing and going on left right now

05:03.240 --> 05:09.420
what does the meaning go on the right side so be off what is the right side here for this node 270 it

05:09.420 --> 05:14.270
is here at 270 so site is known right side is null.

05:14.310 --> 05:16.050
So again it will call it since that null.

05:16.290 --> 05:21.900
So again the activation that guard is created at the same place a new activation that God is created

05:22.260 --> 05:24.840
but the equal null but this call is different.

05:24.840 --> 05:26.190
This was over already.

05:26.300 --> 05:28.680
So a new gun so again for this call.

05:28.840 --> 05:31.420
PS Not No no no these none.

05:31.710 --> 05:34.490
So it can not enter inside if nothing is done.

05:34.800 --> 05:40.530
So this will terminate once this terminates its activation that code is deleted and it goes back to

05:40.530 --> 05:45.750
the previous function call that is 217 back on this one I spoke to 70.

05:45.930 --> 05:49.890
All three steps are completed three steps are completed.

05:50.340 --> 05:55.060
So this is also completed go back to the previous call.

05:56.390 --> 05:57.390
Who then.

05:57.600 --> 05:58.820
This one.

05:59.100 --> 06:05.850
This one for this call to step aside or printing and calling on left side calling on left side.

06:05.850 --> 06:06.600
This one.

06:06.670 --> 06:13.250
No it has to call on the right side that is 300 so it will call itself upon right side.

06:13.350 --> 06:19.900
There is 300 so far 300 a new activation record is created that displays for different function gone

06:20.160 --> 06:20.410
now.

06:20.550 --> 06:21.490
This is not null.

06:21.720 --> 06:24.780
Three steps so I'll perform those three steps quickly.

06:24.780 --> 06:26.550
First one is print the value.

06:26.570 --> 06:27.390
So what is the value.

06:27.390 --> 06:33.790
9 9 is spring back then calling itself again for left China that is zero.

06:34.020 --> 06:36.640
So activation that code is created once again.

06:36.730 --> 06:37.950
But this started me needs.

06:38.070 --> 06:38.880
So this so what.

06:38.880 --> 06:42.040
Back to this one second third step.

06:42.150 --> 06:43.130
Call up and write.

06:43.130 --> 06:44.620
China is also null.

06:44.690 --> 06:46.530
So new activation the code is created.

06:46.560 --> 06:47.490
This is null.

06:47.610 --> 06:48.710
So this terminates.

06:48.720 --> 06:50.780
So this is over.

06:51.210 --> 06:52.220
Go back to this call.

06:52.230 --> 06:54.840
This call three steps out were all three steps out of work.

06:54.840 --> 06:55.920
So this call finishes.

06:56.130 --> 07:00.160
So this ends Nada goes back to Q10.

07:00.510 --> 07:02.180
This one for this one.

07:02.220 --> 07:03.970
All three steps are completed.

07:04.180 --> 07:06.150
Printing call up on left child.

07:06.150 --> 07:07.190
Call upon the right chain.

07:07.350 --> 07:10.570
So below this there are more steps that are finished.

07:10.660 --> 07:11.790
Are also finish.

07:11.820 --> 07:17.260
So this function call has finished so it will go back to previous call.

07:17.260 --> 07:26.230
This mean gone sort of this two steps son completed third step is remaining so I'll stress this little

07:26.230 --> 07:28.410
more here.

07:28.810 --> 07:31.330
So third step it has to perform that is to go on.

07:31.320 --> 07:34.600
Right child BRT upon right China right.

07:34.630 --> 07:43.410
Child is 230 new activation record is created about this one with a good 30 for this call.

07:43.410 --> 07:48.570
This will only become bigger good and so we're just calling this one this is not null.

07:48.720 --> 07:54.590
So not No means three steps it has to perform in the value call up on left child call upon right.

07:54.930 --> 07:56.010
So the value.

07:56.040 --> 07:57.010
So what is the value.

07:57.020 --> 08:09.510
5 right then call upon left child pre order of left that is 310 I afterwards Foster 310 a new activation

08:09.510 --> 08:16.320
the card is created the to 310 for this again not null three steps so bring the three times value what

08:16.320 --> 08:19.190
is the value inside that seven then call it.

08:19.200 --> 08:24.500
So far none so to assign zero new activation the card is created.

08:24.870 --> 08:25.990
But this ends.

08:26.010 --> 08:27.470
So this is terminated.

08:27.510 --> 08:30.210
So this is a deleted goes back to this call.

08:30.330 --> 08:34.860
This call again zero is GA for a child p zero.

08:34.950 --> 08:35.970
This terminates.

08:36.090 --> 08:38.590
It ends goes back to this call.

08:38.610 --> 08:39.840
This is completed.

08:39.840 --> 08:41.070
So this is deleted.

08:41.250 --> 08:44.980
Then go back to this call 3 so before.

08:45.150 --> 08:50.540
All right child 3 or indeed 3 during the for this one.

08:50.640 --> 08:52.890
It will bring the 2 and it will call it.

08:52.890 --> 08:55.100
So 4 0 and 0.

08:55.590 --> 08:57.920
Okay so two more zeros are created.

08:58.860 --> 09:00.560
Then they are deleted.

09:00.570 --> 09:01.280
This is over.

09:01.320 --> 09:02.820
So 3 grand is finished.

09:03.420 --> 09:06.350
So 3 grandiose finish then good ideas also finish.

09:06.510 --> 09:10.420
Then there is also finished it not right output like a second I don't put first.

09:10.470 --> 09:11.430
8 was dead.

09:11.640 --> 09:13.870
Then 3 was brain dead.

09:14.040 --> 09:23.440
Then for the 9 more sprinter than 5 then 7 then 2.

09:24.330 --> 09:25.980
So this the output of preorder.

09:26.430 --> 09:33.900
So tracing 3D has expanded like anything so once you know how this the trees are generated.

09:33.900 --> 09:39.790
If you are familiar with this tree you can even vote called upon this tree structure itself you're going

09:39.790 --> 09:44.250
to have to generate a huge tree but you have to do it at once.

09:44.250 --> 09:51.640
Then you get diarrhea how to do it directly upon the tree No let us analyze the trees.

09:51.700 --> 09:54.390
First of all total how many calls are there.

09:54.400 --> 10:06.520
Let us check the number of calls 1 2 3 4 5 6 or 7 eight nine ten eleven twelve thirteen fourteen fifteen

10:08.100 --> 10:09.830
girl fifteen calls.

10:10.060 --> 10:19.640
Actually if you see these return addresses that are equal to notes and these numbers are for nulls.

10:19.730 --> 10:25.720
So if you remember we already saw that if there are any knowns that there will be and plus 1 pointers.

10:25.760 --> 10:33.470
So total number of calls out to N plus 1 and the form number of nodes then and plus 1 for number of

10:33.470 --> 10:34.540
null pointers.

10:34.580 --> 10:37.420
So total number of calls are good plus 1.

10:37.520 --> 10:40.870
Then once again I will show you in which order the calls are made.

10:40.880 --> 10:46.040
This was the first call second gone third and fourth call.

10:46.100 --> 10:48.740
Fifth call then this was the sixth call.

10:49.110 --> 10:58.550
Then this four seventh call an eight call then go back and come despite this the ninth call tenth call

10:59.340 --> 11:11.000
Levent do it go back and come the site 13th call 14th and 15th call in this order these calls are made.

11:11.460 --> 11:15.910
If you know in which order the calls are made then you have understood the procedure.

11:16.070 --> 11:16.920
Working.

11:17.120 --> 11:19.100
Then let us look at the stack.

11:19.110 --> 11:22.250
How many activation the cards that are created and destroyed.

11:22.440 --> 11:25.740
Depends on the number of calls for those 15 cards.

11:25.740 --> 11:28.470
So 15 activation that courts were created in this strike.

11:29.370 --> 11:38.410
But you see at the time how many active which in the course of the day 1 2 3 4 1 2 3 3 levels are there

11:39.120 --> 11:40.030
plus 1.

11:40.290 --> 11:43.540
Because 4 notes also called sodomy to right.

11:43.800 --> 11:50.550
So it depends on this what you call dimension of a tree that is height of a tree.

11:50.790 --> 11:56.120
No doubt it is for but the height this 0 1 2 height the school only but they are 4.

11:56.280 --> 12:00.890
Don't go on count bonbon count it is dependent on height.

12:00.990 --> 12:07.270
So I can see that the size of the stack will be height plus to whatever the height may be.

12:07.860 --> 12:13.170
So if I light height plus two then I can see that it is dependent on height value that was constant

12:13.170 --> 12:14.610
always to you'll be adding.

12:14.610 --> 12:18.390
So the actual size it depends on the height.

12:18.420 --> 12:22.300
So you're seeing that depends on height is not wrong.

12:22.300 --> 12:22.500
Right.

12:22.740 --> 12:24.760
So don't want to comment all this.

12:24.780 --> 12:28.790
So how many activations that course are created of order the size of the stack.

12:28.860 --> 12:30.470
It depends on the height of a tree.

12:30.480 --> 12:33.040
That's all that's the procedure to have analyze.

12:33.070 --> 12:38.010
So in the next procedure in the in the coming procedure I may not be showing stock every time you know

12:38.010 --> 12:39.030
hard books.

12:39.090 --> 12:43.980
I'll try to keep the same example so that you all even know about this and you already know the tracing

12:43.980 --> 12:50.070
tree so with the minimum work I've tried to show the tracing of remaining functions upon the tree.













WEBVTT

00:00.330 --> 00:04.260
Let us look at in order traversal up on a tree.

00:04.740 --> 00:11.230
So already I have our tree available here and recursive in order traversal function.

00:11.520 --> 00:14.640
This is a recursive function similar to pre order.

00:15.060 --> 00:17.780
What is the difference function name is different.

00:17.770 --> 00:21.060
Yes it is in order for function name is different than three steps.

00:21.060 --> 00:27.100
Yes it is having three steps but if you observe in pre order that force in the beginning first step

00:27.100 --> 00:34.170
was brain death then pre order calls for there to qualify but no two calls are these calls and apprentices

00:34.390 --> 00:36.090
in between them.

00:36.090 --> 00:36.980
So it is in order.

00:37.740 --> 00:41.590
So guess how to write out of print that should be at the end.

00:41.970 --> 00:44.520
Yes print should be ordained next startup.

00:45.170 --> 00:48.500
Now let me show you how this function walks up on this train.

00:48.510 --> 00:52.420
So I will just show you the tracing tree of this function.

00:52.440 --> 00:56.180
I will not show the stack already we have seen detailing preorder.

00:56.250 --> 01:03.500
So let us just generate tracing tree and understand how in order is working here and writing the output

01:04.350 --> 01:10.810
first time and the function is scarred in order first time the address of this route as boss attempts

01:10.880 --> 01:11.690
200.

01:11.860 --> 01:12.220
Right.

01:12.540 --> 01:21.970
So first time and we call we call it like this in order good and we pass route so 200 is past so we

01:21.970 --> 01:30.400
will down this number dominant function takes addresses but address this may confuse us from the tree

01:30.400 --> 01:35.920
if I ask your read you will try to read values only data only so v before data.

01:36.290 --> 01:37.550
So does this make us feel.

01:37.550 --> 01:43.250
So in stuff writing addresses I they don't data if at all anymore required.

01:43.440 --> 01:50.780
They write on there does we know this is our boss but I will try to write data so instruct two 200 let

01:50.790 --> 01:55.080
us see it is called upon a node in which data is 8.

01:55.220 --> 01:58.180
So that makes a sense to us right.

01:58.690 --> 02:00.430
So let us continue.

02:00.430 --> 02:01.460
This is not known.

02:01.480 --> 02:05.580
Third has to perform three steps the first step is called itself upon left China.

02:05.710 --> 02:09.890
Second is pretty badly done untold is got itself up on the right chain.

02:09.970 --> 02:11.470
So the first step happens.

02:11.590 --> 02:17.830
That is calling itself upon left China left China's three segment call itself upon left child that is

02:17.830 --> 02:20.980
3 and the second step printing it is done afterwards.

02:20.980 --> 02:26.860
Let us finish this then calling up the right child will be done after work facilities finish this function

02:26.890 --> 02:33.610
that is in order upon nor the three or four nor three it is not null yes again three steps got up on

02:33.610 --> 02:39.090
left child print and call up on the right chain call up on left child print and call upon a child.

02:39.370 --> 02:46.780
So far this step is called upon left child in order of left child and all this for fuss it will call

02:46.780 --> 02:49.230
itself up on left then other two steps.

02:49.240 --> 02:54.560
First let us finish this then we will perform other two steps then what about this.

02:54.590 --> 02:58.890
Value for it is not known again perform three steps.

02:58.890 --> 03:00.330
So go on left side.

03:00.440 --> 03:10.130
So this time it will return home in order of null in order of null nothing will happen then what is

03:10.130 --> 03:11.000
the second step.

03:12.720 --> 03:16.200
Rental data so this time written into data.

03:16.390 --> 03:18.420
Value for is printed.

03:18.850 --> 03:20.340
Then what is the next step.

03:20.350 --> 03:21.430
Go on the right side.

03:21.730 --> 03:24.610
So what is there on the right side off for now.

03:24.880 --> 03:28.280
So again for the right side also it is in order of.

03:28.300 --> 03:30.820
No then nothing would happen.

03:30.850 --> 03:32.960
See there's a lot of value 0.

03:33.040 --> 03:38.110
Actually I'm sure values here but here I have to show that in some writings I'll be sure that this is

03:38.110 --> 03:39.520
not next.

03:39.520 --> 03:46.530
This has finished it will go back to this nor that it's towed Nor this one for this fossil step is complete

03:46.530 --> 03:52.780
that up on left side everything is completed not the next step is print so it will print the data.

03:52.930 --> 03:57.840
The value is three right here already we have the value 3 so frustrated that it was printed was flawed

03:57.850 --> 04:05.170
and on an x value as a 3 then Tada step it has to perform that is go on the right hand side of the 3

04:05.200 --> 04:14.320
nor the 3 What is there it will call upon node 9 again three steps go to left but in the value go great

04:14.760 --> 04:24.670
for left it is none nothing so print 9 9 then go on right site there is nothing this is completed so

04:24.670 --> 04:32.110
this is also completed all three steps go back then here print eight does this step three meaning see

04:32.110 --> 04:38.620
this portion is completed totally completed eight print eight then go the right site so far right side

04:39.010 --> 04:39.490
right side.

04:39.490 --> 04:49.960
Notice five in order of five for this go to this site in order of seven other two steps sorry meaning

04:50.080 --> 04:57.100
for inaudible seven left side in order of zero nothing is there then bring seven in order of zero nothing

04:57.100 --> 05:05.740
is that so seven is printed this is completed go back to this one in five call upon the right side right

05:05.740 --> 05:14.080
side is to do for this upon left side nothing is there printer two then up on the right side nothing

05:14.080 --> 05:17.330
is ten so there's nothing they'll terminate right.

05:18.400 --> 05:21.880
So the values that were printed after this was 5 and 2.

05:22.240 --> 05:31.480
So the output is forty nine eight seven five to let us do it directly by moving finger around it I said

05:31.510 --> 05:37.380
that for in order keep your finger on the top of this node right put it in this direction right up upward

05:37.410 --> 05:45.770
direction so let us move around is the Baltimore 4 4 then get inside the bottom of 3.

05:45.800 --> 05:56.360
Yes 3 then bottom left 9 yes 9 then get inside really the bottom of 8 8 bottom of seven seven bottom

05:56.360 --> 06:00.870
of five five and bottom of two two finished.

06:00.950 --> 06:07.160
So on set is correct I have shown you three methods in all three methods I was taking the bottom of

06:07.160 --> 06:08.080
four nor right.

06:08.170 --> 06:14.170
So if you observe here in order see branding is done in between in between.

06:14.200 --> 06:17.980
Printing is done in between left sided call and right credit card.

06:18.160 --> 06:21.240
So between Left and Right check printing is done.

06:21.340 --> 06:30.800
So that's all you say move a finger around like this see four then three then nine then eight.

06:30.850 --> 06:37.720
This what I have shown you in preorder if you observe all if you go back to the previous do and watch

06:38.110 --> 06:41.710
preorder printing was done fast so it was on the left hand side.

06:41.710 --> 06:45.160
What happens to the poor starter printing will be done afterwards.

06:45.310 --> 06:53.360
Yes so if you want to modify dysfunction I don't paint the fact then that is postmortem so I don't have

06:53.360 --> 06:59.120
to show you both strata both started as a student exercise you can do it if the small function you can

06:59.120 --> 07:02.600
write on that function so bending will be done afterwards.

07:03.640 --> 07:07.120
No let us do some analysis total how many calls.

07:07.130 --> 07:13.730
One two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen so fifteen

07:13.730 --> 07:16.990
calls we saw them in preorder also fifteen calls for that.

07:17.120 --> 07:22.390
How many loads are data and nodes seven nodes are there right then how many pointers.

07:22.430 --> 07:28.070
And plus one one point us on and so forth each node a call is made and also for another point does concern

07:28.100 --> 07:33.290
me so doodle Gonzaga in plus one so total calls are going plus one.

07:33.800 --> 07:36.850
Now one thing I have to tell you I did not say that in pre order.

07:37.360 --> 07:40.600
What is the time complexity of this traverse.

07:40.790 --> 07:46.080
It depends on how much work it is doing what the work it is doing it is calling and they they've recorded

07:46.080 --> 07:50.340
a to print if possible just printing one step only.

07:50.780 --> 07:56.800
How many times it is printing depends on the number of calls for how many calls are there two plus one.

07:56.810 --> 07:58.810
So what is the degree of this polynomial.

07:58.850 --> 08:06.650
And so the time complexity of traversal is and remember this the time complexity of all the driver cells

08:07.040 --> 08:09.320
or whatever you do up on a binary tree.

08:09.350 --> 08:15.350
Most of the time it is n not next let us look at the order in which the calls are made.

08:15.700 --> 08:25.520
It is the first call was the second gone term Ford calling fifth gone go back sixth gone then come the

08:25.520 --> 08:36.450
side seven gone go back and come this site it gone go back and decide ninth God can gone leavened go

08:36.450 --> 08:46.650
back and call this site to Alcon thirteen con 14 15 con you can observe that the order in which the

08:46.650 --> 08:53.160
calls are made is same as preorder in preorder also same thing was happening because the function is

08:53.160 --> 09:01.890
calling itself two times upon the same three then same amount of calls should be done but the difference

09:01.890 --> 09:07.410
in preorder and in this one this printing was done before her printing is done in between two calls

09:07.560 --> 09:08.660
that's only little difference.

09:09.060 --> 09:15.590
So the calls will be similar what will be the size of the stack size of the stack that we see that depends

09:15.590 --> 09:21.920
on the height of a tree height plus two we analyze that time so the size of the stack will be height

09:22.160 --> 09:29.300
to see you can see order of edge that height of a tree if you remember height of a tree can range from

09:29.720 --> 09:38.240
logon to n that and here is the number of nodes so you know what example the height this log in but

09:38.270 --> 09:42.970
if it is a skilled tree then the height will be n so it depends on the height.

09:43.340 --> 09:49.090
So usually we don't write out of each any other variable if we don't use views and only so that means

09:49.090 --> 09:50.780
either can we logon or.

09:50.840 --> 09:57.380
And so minimum must log in magazine moments and so that's all about in order and post order also gave

09:57.380 --> 10:00.470
you the idea you have to write on the function for stronger.












WEBVTT

00:00.810 --> 00:08.000
In this video we will learn how to write a creative trade travel since we have already seen a recursive

00:08.090 --> 00:08.990
for driver.

00:09.180 --> 00:11.120
We have seen recursive functions.

00:11.250 --> 00:17.910
Now we will write iterative functions for preorder in order for startup recursive functions.

00:17.910 --> 00:19.090
We already saw.

00:19.290 --> 00:25.610
So if you want to convert a recursive function into iterative function that is a function with a loop.

00:25.920 --> 00:30.560
Then you may have to use your own stack.

00:30.720 --> 00:35.870
It's not necessary all this in some procedure but that depends on the procedure.

00:35.880 --> 00:42.000
So in some procedure you may need to have your own statements you have to use your own stack and iteration.

00:42.630 --> 00:44.010
So therefore does the exam.

00:44.010 --> 00:48.270
In this example we are going to use a stack with old stack.

00:48.270 --> 00:53.860
We cannot convert recursion to iteration so first of all I will explain the procedure.

00:53.870 --> 00:56.110
Then after that I haven't tried the function also.

00:56.200 --> 00:57.910
So let us start with the pre order.

00:58.630 --> 01:04.380
Let me show you how we can perform pre order iteratively with total recursion.

01:04.630 --> 01:07.450
Let us perform it up on the street.

01:07.570 --> 01:14.090
As I said I may require a stack so beforehand I will draw a stack and keep it pretty.

01:14.320 --> 01:22.570
Maybe it is useful and here I'm going to write a notebook and one more thing is preorder steps are suspended

01:22.920 --> 01:26.560
then perform preorder on left child and perform pre ordered on.

01:26.740 --> 01:27.090
Right.

01:27.090 --> 01:30.430
Child that is a road left right.

01:30.450 --> 01:35.480
So rudiments paid for first pay then go to that site then go to right site.

01:35.530 --> 01:38.200
So let us start and follow these steps.

01:38.200 --> 01:41.880
Okay so let us start from root Norbert TS here.

01:41.880 --> 01:45.410
Does the group know what is the first thing I have to do with the data.

01:45.430 --> 01:47.940
So I will print that data it is printed.

01:48.160 --> 01:49.820
Then move on to left.

01:49.930 --> 01:51.650
Okay I'm moving on to left.

01:52.330 --> 01:55.960
Okay then form this again what I have to do.

01:55.960 --> 01:56.800
Printed it up.

01:56.830 --> 01:58.780
Get printed 3.

01:59.050 --> 01:59.790
Then go What.

01:59.800 --> 02:00.950
Go to left site.

02:01.110 --> 02:08.470
Okay go on the left side then printed it out first step here is print the data for this node then go

02:08.470 --> 02:09.170
to left side.

02:09.190 --> 02:13.430
Okay I will go on left site not be with him.

02:13.850 --> 02:14.650
No what.

02:14.770 --> 02:15.920
Go to the right site.

02:17.290 --> 02:23.000
Watch carefully Google right side whose right side this n right side.

02:23.020 --> 02:24.820
Do you have the off of that nope.

02:24.940 --> 02:25.720
No peace there.

02:25.720 --> 02:27.490
So what is t now D null.

02:28.770 --> 02:31.070
Null events it this move in on the tree.

02:31.590 --> 02:33.000
So t became known.

02:33.000 --> 02:38.240
How do you get that this of this more the address of this nor that this node and this address at this

02:38.240 --> 02:40.370
of this notice that this one and that is the truth.

02:40.710 --> 02:45.350
So I should again come from root that fought that fight.

02:45.390 --> 02:46.290
This is the problem.

02:46.860 --> 02:52.320
So I should go back to this node and again remember I should go back to this node also to go on the

02:52.320 --> 02:53.210
right side.

02:53.280 --> 03:00.340
So I need those addresses then hold them all those addresses I should have pushed them in the stack.

03:00.510 --> 03:02.220
Yes that's what I missed.

03:02.490 --> 03:07.100
So let me start over once again I'll remove this.

03:07.100 --> 03:09.210
Let us stock.

03:09.540 --> 03:11.210
First step printed data.

03:11.280 --> 03:12.580
Print 8.

03:12.600 --> 03:13.650
Then what to do.

03:13.650 --> 03:14.670
Go on left.

03:14.880 --> 03:15.630
Going on left.

03:15.660 --> 03:19.330
But again I have to come back on this more so that I can go on right.

03:19.350 --> 03:25.270
So I need the address of this node so I have not read on the addresses here so I will write on and resolve

03:25.320 --> 03:29.680
that node 8 whatever that just maybe I don't know right.

03:29.700 --> 03:30.960
Then go Go left child.

03:31.370 --> 03:31.690
Okay.

03:31.710 --> 03:34.740
Now move B here.

03:34.740 --> 03:36.900
Now what to do with this node printed data.

03:37.060 --> 03:38.230
I'll get printed data.

03:38.260 --> 03:40.360
3 Then you have to go on left.

03:40.470 --> 03:46.500
But before going on left push the address of that node containing data 3 address on that node into the

03:46.500 --> 03:48.000
stack.

03:48.300 --> 03:49.230
That's perfect.

03:49.320 --> 03:50.460
Then go to the left child.

03:51.360 --> 03:52.660
What to do here.

03:52.660 --> 03:57.300
Print for Bush dieters of this one into this stack after pushing Google.

03:57.360 --> 04:05.750
Left child not b became known he became C D and no what stack is not empty.

04:05.870 --> 04:06.990
Stack is not empty right.

04:07.450 --> 04:09.150
OK continue what they want.

04:09.290 --> 04:17.240
I wonder of this more pop or badness or forward go to this more so pop open give it to be so TNA there

04:17.260 --> 04:19.760
to solve this no no in standing here right.

04:20.090 --> 04:29.100
So when is standing here go on the right side so the steps pop out go to that note and move towards

04:29.100 --> 04:29.780
slide change.

04:30.870 --> 04:31.880
Then continue.

04:32.190 --> 04:34.210
Again no seeking is null.

04:34.500 --> 04:36.160
But the stack is not empty.

04:36.260 --> 04:37.640
Pop out an address.

04:37.680 --> 04:39.680
That's what a does of three.

04:39.690 --> 04:48.570
Okay go to this node then move to right side not continue for this nor what do we have to do print push

04:48.570 --> 04:49.780
dials into the stack.

04:49.830 --> 04:51.460
Surely what it does is there in the stack.

04:51.540 --> 04:57.720
So here it will be inserted then will be left side.

04:57.720 --> 05:02.660
It is known but this is not what we are doing pop open address.

05:02.760 --> 05:08.000
Take a d up on that address and then move it to upon the right side.

05:08.350 --> 05:16.860
So right now insert is this null and the stack is not empty pop of this address 8 pay equity over there.

05:17.260 --> 05:18.140
Okay.

05:18.180 --> 05:19.730
Then move to the right side.

05:21.960 --> 05:25.040
So whenever it is null we are doing this right.

05:25.400 --> 05:27.270
Continue these not null.

05:27.360 --> 05:27.870
Yes.

05:27.870 --> 05:28.770
So what to do.

05:28.950 --> 05:36.180
Print the 5 right and push divers of that 5 into the stack address of 5 into the stack.

05:36.180 --> 05:38.040
This is a free space no.

05:38.250 --> 05:41.300
Then move to 2 left China.

05:41.460 --> 05:45.550
Again this is not null do work print 7.

05:45.610 --> 05:48.210
Go to left child before Google left child.

05:48.240 --> 05:54.210
Insert the address of 7 into the stop and go to left child these NULL NULL limits what we are doing

05:54.560 --> 05:59.130
pop out the address go to that node and move to x ray change.

06:00.810 --> 06:06.360
So whenever D null we are doing this again this is another pop or die address.

06:08.020 --> 06:11.410
Go to that node and move to write change.

06:11.460 --> 06:22.390
This is not null then not null printer to go to left side for F child again was a dinosaur that gnawed

06:22.420 --> 06:26.370
when you are going on the left child put the address and good left child.

06:29.190 --> 06:35.030
These non pop of an address Google that ignored and moved to right.

06:35.030 --> 06:40.040
Child so these again not these none.

06:40.560 --> 06:42.790
And there is nothing in the stack.

06:43.080 --> 06:44.650
There's nothing in the stack.

06:44.750 --> 06:47.810
So we have finished the procedure and we got better.

06:48.210 --> 06:55.260
This is preorder for this is how the procedure works so to stop this procedure.

06:55.310 --> 06:56.630
Then D No.

06:56.960 --> 06:58.830
As well as the stack is empty.

06:58.940 --> 07:01.490
Now let us solidify our reserve preorder.

07:02.120 --> 07:05.120
I'll just a trace with the finger I'm sure you preorder.

07:05.120 --> 07:08.480
I just said we should point the finger in this direction.

07:08.620 --> 07:10.870
The left hand side of eight yes eight.

07:10.910 --> 07:18.950
The Nexus three years for that didn't get inside 9 then get inside 5 then 7 9 2.

07:19.070 --> 07:20.740
Yes it is perfect.

07:20.820 --> 07:26.370
Now I have to write on the program so I get a few things are there a function preorder taking point

07:26.370 --> 07:33.480
a d upon route and a stack of all server level assume that stack is all initialized what are the steps

07:36.080 --> 07:43.320
very beating the steps how long is not known unstuck is not empty.

07:43.680 --> 07:52.230
Ok so repeating the statements I will write on my loop wine being not equal to.

07:55.150 --> 08:08.720
It's not anger on not is empty as steam stack was not empty so why there is not no and the stack is

08:08.720 --> 08:09.860
not empty.

08:09.860 --> 08:16.340
If a b is a null false stack is also empty false both are false it will stop.

08:16.340 --> 08:21.440
So I should use order that the steps the steps are very simple.

08:21.440 --> 08:23.450
If a t is not known.

08:23.960 --> 08:27.380
Let us see this step again from here to get an idea.

08:27.500 --> 08:37.800
If a d not no print data Bush address Google left China right.

08:38.160 --> 08:39.080
If it is not.

08:39.310 --> 08:40.040
So here.

08:40.200 --> 08:48.180
If a d not known then three things in the data one should guide us in the stack and move to left China

08:48.590 --> 08:53.570
in the data push aid into the stack and move to left China.

08:54.180 --> 09:02.370
If it gets not known if it is NULL ELSE WHAT WE SHOULD DO IS WHAT WE SHOULD DO see when it was null.

09:02.580 --> 09:04.110
What do we were doing here.

09:04.230 --> 09:06.460
What we did at that time when it wasn't.

09:06.840 --> 09:09.290
We are both in their does and Google right China.

09:09.690 --> 09:15.790
So passport and they address from the stock passport and it was from the stock and go to chain.

09:16.370 --> 09:19.250
That's on and off loop and a function.

09:19.310 --> 09:26.670
That's all it is the iterative function for preorder traversal which is you utilizing a stack and one

09:26.670 --> 09:31.980
more important thing is that the stock should be off which type integer type character type which type

09:32.340 --> 09:37.350
it is storing the addresses so it should be of a type address of this nor.

09:38.160 --> 09:40.170
So while writing the program I will show you that.













WEBVTT

00:01.080 --> 00:06.440
Next with a small change I can convert this procedure for in order to traverse.

00:07.070 --> 00:13.860
So let us look at in order Carson never seen order Travis on in order to ever since his first go to

00:13.860 --> 00:17.370
the left right then print then go to write check.

00:17.760 --> 00:20.170
So left root right.

00:20.190 --> 00:21.350
That's how we read it.

00:21.360 --> 00:30.850
Let me quickly trace the essential you we need a stock on the start from root that so initially that

00:30.850 --> 00:33.460
these not come and the stock is empty.

00:33.460 --> 00:37.010
Now let us look at this preorder see preorder first.

00:37.030 --> 00:43.590
If these not no obvious first step is printing but then in order first we go to left China.

00:45.380 --> 00:46.650
Then we should not print.

00:47.000 --> 00:53.080
OK let us move to left China but ask for preorder fast push dollars and go left China will get pushed

00:53.090 --> 00:56.100
out of that 8 and go to left China.

00:56.430 --> 00:59.220
Okay we will go do this that again.

00:59.240 --> 01:01.120
This is not normal print.

01:01.190 --> 01:02.140
We will not print.

01:02.180 --> 01:03.850
This is step will not perform.

01:03.910 --> 01:08.490
Bhushan go to left China push the address of 3 and move to left China.

01:08.620 --> 01:12.800
Kim move to left China then this is not null again.

01:12.800 --> 01:19.850
So what should I do to solve this for into the stock and go to left China.

01:20.270 --> 01:20.570
No.

01:20.570 --> 01:24.220
This is null if it is not known.

01:24.500 --> 01:29.760
These are steps you to performing we are not performing the sprints.

01:29.920 --> 01:33.530
We were performing two step nor does null and Spock.

01:33.620 --> 01:39.610
So in this pre order what we are doing pop out go put a chain what shit.

01:39.940 --> 01:40.630
Pop punk.

01:41.850 --> 01:45.860
We will get dirty so for not before agreeing to write.

01:45.860 --> 01:50.570
Child we should print before going great television print and in order.

01:51.230 --> 01:52.960
So printing should be done now.

01:53.210 --> 01:54.890
We are about to go on right child.

01:54.910 --> 01:56.200
See that's about to go on right.

01:56.200 --> 01:58.640
Che so before that first you print.

01:58.640 --> 02:01.490
So it means I should print here first.

02:01.490 --> 02:05.690
So print this first then move B to our child.

02:06.400 --> 02:10.680
So print def is removed from here next.

02:12.140 --> 02:18.330
So with a little bit of observation I can say that in the pre order before going on left child we were

02:18.330 --> 02:22.650
printing but then in order before going on right China printed.

02:22.980 --> 02:26.970
So this function becomes in order.

02:27.610 --> 02:30.630
So a minor change has made it out in order.

02:32.250 --> 02:33.580
That's followed in order.

02:33.810 --> 02:34.940
One thing I want to show you.

02:35.220 --> 02:40.800
What does the Bangkok look city of dysfunction in preorder until we saw an inaugural so same function.

02:40.800 --> 02:44.290
Just a change of position of print function.

02:44.340 --> 02:45.510
This a minor change is there.

02:45.930 --> 02:49.560
So what is the complexity loop is that loop.

02:49.560 --> 02:53.160
How long as many nodes added that many times it will repeat.

02:53.250 --> 02:57.220
So what is the time complexity order of an hour growth.

02:57.330 --> 03:00.440
And and what was the size of the stack.

03:00.510 --> 03:05.580
Depends on the height of a tree is style depends on the height of a tree.

03:05.620 --> 03:10.470
Now both started both started as little complex so I could keep the same court.

03:10.560 --> 03:14.530
Let us see what about both strata let us see both start.

03:14.550 --> 03:16.050
Both daughters see is that first.

03:16.050 --> 03:17.880
Go on left side then right.

03:17.890 --> 03:22.130
Child then print data Google left also right.

03:22.160 --> 03:24.210
Also means you should not bring it here.

03:24.860 --> 03:27.840
So after finishing both left and right we should print.

03:27.920 --> 03:30.310
So let us take us to our country is this fun.

03:30.320 --> 03:36.850
So I take a stock start from here see the procedure will be similar to this one only with some changes

03:37.130 --> 03:40.950
so watching just like wild bear to study that we will taste it.

03:40.970 --> 03:46.600
With the help of that function only actually the function is free in order motivated we required changes.

03:46.640 --> 03:50.950
We wouldn't make the changes there so I seven follow that procedure only in traffic.

03:50.960 --> 03:56.880
So let us start a D on this one so please not know what is the first step push dangerous on that morning

03:56.880 --> 04:04.780
to the stack 8 then move to lift change or move pull off chain so he's not null.

04:04.860 --> 04:10.410
So if it is not no push and move lift so push that this off 3 and move lift.

04:12.400 --> 04:18.890
Once status of 4 and move left.

04:18.890 --> 04:19.890
No I know.

04:21.140 --> 04:27.280
So another means what we should do else pop out print and go to write check.

04:27.360 --> 04:29.670
So let us do it pop out.

04:29.690 --> 04:32.400
So this is deleted.

04:32.630 --> 04:33.460
D here.

04:35.490 --> 04:36.790
Print can go right.

04:36.810 --> 04:38.010
Child No.

04:38.010 --> 04:45.540
Don't print both start elements first go to right train afterwards print left child All right go go

04:45.540 --> 04:46.820
right and then print.

04:46.890 --> 04:48.490
So we should not bring this one.

04:48.540 --> 04:54.270
We should not print it should not be printed by boat and go to great shape.

04:54.650 --> 04:57.900
Okay I will go to great shape and good great shape.

04:58.530 --> 04:59.750
So Rachel is what.

05:00.300 --> 05:02.650
If it is no Popo then go to write chain.

05:03.000 --> 05:09.320
So which one I get at this of three or four I did not print I should print that for also.

05:10.250 --> 05:11.200
That's it.

05:11.220 --> 05:15.720
So the differences I should push at that address are for once again.

05:15.720 --> 05:19.530
First time it was pushed so that we can go on the right side.

05:19.950 --> 05:22.800
Second time we need so that we can predict.

05:23.100 --> 05:27.740
So before going to write child Bush's dad did this of dad before.

05:27.750 --> 05:32.550
Once again you do this Jack once again push it then go do rate change.

05:34.080 --> 05:38.900
So I will write on the code afterwards so push it again and then go to write.

05:39.510 --> 05:45.880
Not these not once again pop up whose address we get for sentence.

05:46.030 --> 05:47.750
Now see the second problem.

05:47.910 --> 05:50.860
Second problem first time we pop out.

05:51.000 --> 05:52.250
That was right.

05:52.750 --> 05:54.600
This time we are popping out.

05:54.720 --> 05:55.940
This is for printing.

05:55.950 --> 05:57.250
We are back on forward.

05:57.360 --> 06:03.240
Now we should print now how do know that a doctor dress for four right side and this address is for

06:03.240 --> 06:03.960
printing.

06:03.960 --> 06:05.100
There should be some difference.

06:06.320 --> 06:07.820
Yes that's the problem.

06:08.600 --> 06:16.130
So what we should do when we are pushing it the second time we should push negative press justice this

06:16.130 --> 06:17.260
cannot be negative.

06:17.270 --> 06:25.300
No no you can work Doug address into an integer and store negative integer then you are using convert

06:25.300 --> 06:27.160
to an address positive I guess.

06:27.200 --> 06:27.670
Okay.

06:27.740 --> 06:28.940
We can do that.

06:28.940 --> 06:31.040
So push this once again.

06:31.040 --> 06:38.710
So would the time Foster money pushing push positive second time and you're pushing it is negative so

06:38.710 --> 06:41.150
positive adjustments a good writer.

06:41.290 --> 06:48.870
Negative harassments bring the data so radically modify that one and you have to praise the complete

06:48.880 --> 06:50.420
working on this example.

06:51.070 --> 06:51.610
Okay.

06:51.670 --> 06:55.510
This is sufficient if I explain it will be confusing.

06:55.930 --> 06:59.080
So you take pen and paper and praise this function.

06:59.070 --> 07:00.290
Hypothetically write on the phone.

07:00.310 --> 07:04.580
So I have explained you important points in this one that we have to push that as a still time.

07:04.600 --> 07:11.590
So I will write on the code that solve it that I finish tracing you do you take an example 3 and you

07:11.590 --> 07:15.180
trace everything and generate the complete output by yourself.

07:15.580 --> 07:17.550
So there is a story in exercise.

07:17.660 --> 07:19.040
I'm writing the code.

07:19.200 --> 07:21.270
Bob got an address from the stack.

07:21.510 --> 07:29.460
I just said the stock will be off integer type so I will take one long integer a temporary value P E

07:29.490 --> 07:35.140
and be OK so I will pop out a value from the stack.

07:35.140 --> 07:44.650
Bob s t so I'll get integer value anything but any variable not check whether this positive or negative

07:45.580 --> 07:49.330
if it is positive means we have to push again and go to write.

07:49.690 --> 07:53.830
If it is negative means we should print so fast check if it is positive.

07:54.310 --> 07:58.050
If a temp is greater than zero means positive.

07:58.870 --> 08:05.830
If it is positive then do what pushes the negative value of temp into the stack push the negative value

08:05.830 --> 08:12.940
into the stack then move to right side temp is having an address but actually it is in digit value.

08:12.940 --> 08:19.010
I type costed it go and address then gaps outside that he's moving on goods right.

08:20.610 --> 08:22.230
Okay the syntax I have written.

08:22.410 --> 08:24.650
Let us see how it works OK.

08:24.660 --> 08:31.680
While writing the program once again if that is positive push of the negative address once again and

08:31.830 --> 08:39.480
move ready to write check if it is not a greater than zero means ends as means it is less than equal

08:39.480 --> 08:40.160
to zero.

08:40.240 --> 08:47.040
An inmate will not be zero here so this less negative if it is negative than what we should do the data

08:47.160 --> 08:49.050
and again to make a deal has none.

08:50.100 --> 08:51.200
So print the data.

08:52.530 --> 08:59.280
So print the data by typecasting that numeric value and go I press so print the data and then make it

08:59.360 --> 08:59.920
s s.

09:00.990 --> 09:04.230
So this is the extra work required for fourth target.

09:04.530 --> 09:09.750
We have to push it there just as two times one for going on the right side one for printing so positive

09:09.750 --> 09:16.160
and negative interest as we are pushing the extra work that we required in both starter Thomas so that's

09:16.160 --> 09:19.890
all with the iterative version of free driver since.








WEBVTT

00:00.170 --> 00:06.480
And this we do have a look at iterative procedure for pre order in order to which I already have discussed

00:08.150 --> 00:12.600
so I have already written a program C language program for creating a tree.

00:12.620 --> 00:17.960
If you remember in the previous video that same program I am carrying on and already I have written

00:18.380 --> 00:25.210
recursive functions for preorder in order and post starter now live in the right iterative procedures

00:25.280 --> 00:27.830
that is using loop so for loop.

00:27.830 --> 00:34.250
I also need a stack so already I have taken a stack header find I have created a header fight just how

00:34.250 --> 00:40.250
I have created for Q Same way I have done it this is a nor did I keep a pointer double pointer that

00:40.250 --> 00:45.820
is for update then I haven't done a function for creating a stack with just creating a stack here.

00:45.830 --> 00:52.430
These are the functions already we have seen in stock using money that I have already implemented them.

00:52.670 --> 00:55.180
So this push Bob is empty is full.

00:55.310 --> 00:57.010
All these functions already there.

00:57.110 --> 01:02.810
So this stock using buddy this I'll be using it in the iterative procedures.

01:02.860 --> 01:06.650
Now let us come back to the C program that is main function program here.

01:06.680 --> 01:11.510
I will write on the preorder traversal function that is using loop iterative version.

01:12.080 --> 01:13.390
So let us try to function.

01:13.400 --> 01:14.840
I will apologize.

01:14.840 --> 01:25.590
I preorder and it should take struck node pointer to Ruth unhindered needs a stack.

01:25.590 --> 01:35.620
So create a object of type stuck a sticky then I should call a function that is stock to create for

01:36.190 --> 01:41.860
initializing a stack so I will send this address of the stack as well as I will create a very good size

01:41.890 --> 01:42.960
so that that is sufficient.

01:42.970 --> 01:44.640
So hundreds of the size of the stack.

01:47.250 --> 01:53.810
Now the procedure is why Loop Line p r not is empty.

01:55.190 --> 01:59.720
This is empty is there in the queue also in the stack also so for stack I have changed the name to is

01:59.720 --> 02:05.210
empty stack unreal positive stack it will check whether the stack is empty or not.

02:06.310 --> 02:08.820
And here FP is not null.

02:09.040 --> 02:19.540
We will bring the data from e percentile d e data then I should push this into a stack so address of

02:19.630 --> 02:29.760
stack and point a b if it is not null then we should move on bool left child l child then else if b

02:29.760 --> 02:32.690
is null if B's null.

02:32.860 --> 02:41.170
Then we should pop out the address from the stack that is Ampersand SDK and ticketed and B then P should

02:41.170 --> 02:46.590
move on to right child that's it deserted.

02:46.640 --> 02:51.330
Simple procedure that is iterative procedure for finding pre order traversal.

02:51.670 --> 02:56.750
Now here in the main function already I have this a tree create function then and stuff for starter

02:56.810 --> 03:07.070
I'll just change it to preorder and I will call this function I pre order function let us on the program

03:10.880 --> 03:19.570
function name is that small letter I have to change this one this is stack small C Create let us run

03:19.570 --> 03:25.280
it now asking for the truth value and its Left childless a.

03:25.330 --> 03:32.020
Right Charlie is 30 then I don't have any of the children so all these are minus one yes preorder is

03:32.030 --> 03:33.580
10 Birdie 30.

03:33.920 --> 03:36.920
It's a lot of King let us run it once again.

03:39.630 --> 03:40.630
Roll this ten.

03:40.670 --> 03:41.610
Child is twenty.

03:41.640 --> 03:44.250
A child is thirty at its left child is forty.

03:44.250 --> 03:51.030
That is right child is fifty left child at sixteen I cherish seventy then I don't have any n at all

03:51.150 --> 04:04.590
so all I have to mention them as no yes pre order is and Brandy 40 and 50 30 60 70 so left hand side

04:04.590 --> 04:07.930
is 20 40 50 on right hand side is 36 to 70.

04:08.050 --> 04:14.050
So here is the pre order so it's like perfectly now how about in order.

04:14.250 --> 04:20.940
So I will copy this function as it is this preorder function I will copy it

04:24.150 --> 04:35.970
copy then paste in stuff I preorder I will Paul I in order and stuff.

04:36.020 --> 04:38.290
Pretty tough call here.

04:38.660 --> 04:41.360
I should call it before going on the right child

04:45.470 --> 04:55.300
then instruct preorder I will call in order let us call the function I in order here next fall see if

04:55.300 --> 04:59.220
you remember just a change of location of print the function will change too.

04:59.710 --> 05:01.030
In order traverse.

05:01.300 --> 05:02.470
Let us run the program

05:05.160 --> 05:08.060
asking for the loop and left Charlie stranded.

05:08.090 --> 05:15.480
Child is thirty that I don't have any other data so I know this one is in order it is printed and tidy

05:15.950 --> 05:16.530
it's perfect

05:19.390 --> 05:25.600
so this program is little Lindy because already you should have saved this Q and stack and you can utilize

05:25.600 --> 05:28.350
those things here so that's all in this video.











WEBVTT

00:00.720 --> 00:04.790
The topic is level order traversal of binary tree.

00:04.820 --> 00:06.710
Here is an example of banditry.

00:06.720 --> 00:15.380
Already we have learned about level order again and repeated level order means traversing all the waters

00:15.480 --> 00:17.660
of our tree level.

00:18.390 --> 00:20.230
So first level is 8.

00:20.250 --> 00:24.960
So if I write the output here first level is 8.

00:25.170 --> 00:28.890
Then second level the first round of the three next values 9.

00:29.310 --> 00:34.290
So 3 and 9 the next level could live in 7 6 4

00:37.920 --> 00:42.450
The last level 5 and 2.

00:42.540 --> 00:44.170
This is the output of level order.

00:45.070 --> 00:52.640
So how actually it is done first visit route group is visited then visit its children.

00:52.640 --> 00:54.980
So the first child left child done right.

00:54.980 --> 00:57.010
Check left child check.

00:57.230 --> 01:04.670
Then children of left child seven children orphaned right child then its children.

01:04.970 --> 01:07.290
So first left child is only left child is there.

01:07.370 --> 01:09.190
So we've even gone five.

01:09.260 --> 01:13.320
Rachel is not there then the children off nice children.

01:13.370 --> 01:16.550
That is this one 6 so 6 child is only two.

01:16.660 --> 01:17.800
Only two is visited.

01:18.050 --> 01:20.060
So this procedure requires a queue.

01:20.360 --> 01:26.420
So I take an example queue and again every driver can show you how a queue can help us in traversing

01:26.420 --> 01:27.680
and level order.

01:28.220 --> 01:29.900
So I have a queue ready here.

01:30.320 --> 01:32.050
Let us traverse it once again.

01:32.150 --> 01:38.450
So for that I will take a point or be first visit route visit route.

01:38.510 --> 01:42.620
That is eight and insert the address of eight in the queue.

01:42.950 --> 01:48.860
So address of eight so this will go faster step our initial step.

01:49.000 --> 01:51.640
No other steps repeating step.

01:51.700 --> 01:57.530
Let us look at the building step take out an address from the queue and give it to be.

01:57.560 --> 01:59.200
So that is the address of 8 only.

01:59.230 --> 02:11.160
So okay people point on 8 again on 8 then visits this left child 3 insert the address also 3 in queue

02:14.440 --> 02:15.580
then visit visits the right.

02:15.580 --> 02:17.980
Child 9.

02:17.980 --> 02:21.050
Insert the address of 9 in the queue I'll just write.

02:21.060 --> 02:27.560
9 That is the address of 9 so using B we have visited left child as well as the right child now it is

02:27.610 --> 02:31.800
over what is or these are the steps.

02:31.800 --> 02:38.600
Take order invest some the queue was it left chime inserted centers then visit rite child inserted centers

02:39.780 --> 02:45.720
no continue repeating the steps take out an address from the queue so the next evidence of three so

02:45.720 --> 02:53.040
take a pointer be upon decadence visit left Child Left child and insert the address of node seven into

02:53.040 --> 02:54.230
the q.

02:54.540 --> 02:59.880
Then visit right child there is no right child for this another then we cannot visit so it is completed

03:00.720 --> 03:11.420
then take our next address from the cube that is 9 the system new node visits left child 6 address of

03:11.420 --> 03:21.390
6 in the queue then visit right child 4 address of food input queue X work is all then.

03:21.410 --> 03:30.590
Next address from the queue and make a pee point on that one visit left child 5 push the address of

03:30.680 --> 03:40.140
five in queue then drive child there is no right child live it then take next to us six six apiece pointing

03:40.150 --> 03:48.990
on six left child no left child rape child yes to insert died this of two in Q This all were taken etc..

03:49.000 --> 03:56.790
4 4 left child do have child right child not a child then come on 5 5 is not having any children then

03:57.070 --> 04:01.840
take out 2 and move go to visit left child and a child of 2.

04:01.840 --> 04:11.870
There are no left and right child not queue is empty is empty was the queue becomes empty stop so take

04:11.870 --> 04:14.700
out an address visit left child right turn backs on.

04:14.780 --> 04:20.940
So the procedure is very simple but initially we have first visit a group then we have insert a digest

04:20.960 --> 04:28.520
of route in queue let me write on the procedure for this one the procedure here Q is ready already I

04:28.520 --> 04:29.380
have taken a queue.

04:29.390 --> 04:36.960
Kill should be of type addresses of normal it's not in digit Q or character Q address type.

04:36.960 --> 04:41.120
Q So the data type of scenario should be no order type.

04:41.400 --> 04:41.920
Okay.

04:42.000 --> 04:47.640
While writing the program I will show you that and also the skills should be initialize so initializing

04:47.640 --> 04:55.080
that front point around data point out that we have to do next step I will perform right to be the pointer

04:55.140 --> 05:01.410
that is a Zuma does en route right does the route then first of all put into that data off Route bring

05:01.430 --> 05:06.690
Duff piece of data will be pointing on the route so data is printed then insert the address of this

05:06.690 --> 05:16.480
a B B into Q NQ dissenters in Q Now the procedure is a repeating procedure so I will write on loop why

05:16.530 --> 05:25.530
in we have to stop and Q becomes M D or not is empty Q means as long as Q is not and b continue plus

05:25.530 --> 05:31.980
a step is taken to the address from Q So say the Q take out and it is from q and figured in point A

05:31.980 --> 05:40.130
B then print left charity if it is there if b c left child is there then brenda ps left China's some

05:40.130 --> 05:47.850
data and also insert that the source left child a Q like this this in the auto data is printed that

05:47.850 --> 05:52.690
is 3D printed and diagrams of trees inserted R and Q and A.

05:52.770 --> 06:00.620
Q Similarly check for the right child for a child is there then printed and inserted in Q2 that's it

06:01.140 --> 06:01.550
here.

06:01.560 --> 06:10.510
PS right child means if it is not not put the data and insert died this of duct right child into Q And

06:10.520 --> 06:18.270
the standoff why loop this positively repeating I'm printing all the elements from three so that's all

06:18.600 --> 06:20.910
this is a in order procedure.



















WEBVTT

00:00.520 --> 00:04.800
In this video we look at level order drivers of a binary tree.

00:05.080 --> 00:10.430
So already we have seen a program for creating a banyan tree and performing various travel cells.

00:10.610 --> 00:15.360
So in the same project I'm just adding a function for performing level traversal.

00:15.550 --> 00:17.850
So let us write on a function for level order

00:21.450 --> 00:29.280
which will take gnawed off type root and that is node ignored then.

00:29.610 --> 00:37.680
So inside this we need a tool so I will take the Q Data Structure cue that I should create a Q also.

00:37.680 --> 00:44.130
So let us call it does it create Ampersand Q and the size I will take it as handed a bigger size so

00:44.130 --> 00:45.380
that it is sufficient for me.

00:46.360 --> 00:52.830
Then as per the procedure we have seen first of all we will print the data from the root.

00:52.930 --> 00:54.950
So this is data.

00:55.000 --> 00:59.720
These data we will print off the printing data.

00:59.780 --> 01:02.760
Will NQ the route.

01:03.200 --> 01:05.930
So in queue I will NQ the route.

01:06.020 --> 01:08.250
So he's appointed to the route.

01:08.520 --> 01:14.960
The one thing will change its name from B to route as its a local variable doesn't have exact actual

01:14.960 --> 01:15.380
route.

01:16.130 --> 01:18.980
So you can read it properly and stuff B.

01:19.070 --> 01:22.810
I'm calling it s route so route is inserted into the queue.

01:23.510 --> 01:26.690
Now while not is empty.

01:26.700 --> 01:35.140
Queue as long as queue is not empty we will print left child on the right chart and if there is an order

01:35.140 --> 01:37.080
we will also include into the queue.

01:37.480 --> 01:44.350
So first of all the route D queue of value from the queue.

01:45.710 --> 01:57.070
Secured and if routes left Charles there then bring that left child print def percentiles D.

01:57.250 --> 01:59.930
And some space routes.

01:59.980 --> 02:05.370
Left child some data sprint at ironed.

02:05.400 --> 02:06.750
Left Charles NQ

02:10.210 --> 02:11.270
inserted in the queue.

02:11.290 --> 02:13.270
That is the routes left child.

02:15.470 --> 02:20.600
Sol then again we should check with the right channels there.

02:20.610 --> 02:24.530
If right channel is there then that should also be treated in the same way.

02:24.630 --> 02:27.550
So I copied and pasted and this is right.

02:27.550 --> 02:29.580
Child so right.

02:29.580 --> 02:30.710
Child instead then.

02:30.820 --> 02:34.850
Right child it is printed and it is NQ.

02:35.910 --> 02:36.770
That's all.

02:36.780 --> 02:40.640
So after this loop so there is nothing we have to do.

02:40.680 --> 02:41.760
So this is the level order.

02:42.180 --> 02:44.940
So that solves the level order function.

02:45.140 --> 02:49.800
I know inside the main functionality create the trees already there.

02:49.800 --> 02:54.170
So now I will call level order function level order.

02:57.620 --> 03:00.470
POS root as a pointer.

03:00.550 --> 03:01.580
Let us run this

03:05.150 --> 03:12.320
so I've will the N that is root node on its left child is 20 right channels 30 x left childless 40 and

03:12.320 --> 03:15.040
right and 50 then 60s and 70s.

03:15.050 --> 03:17.870
So I should get all the elements and the level Lada.

03:17.890 --> 03:21.210
10 20 30 40 50 60 and 70.

03:21.260 --> 03:23.870
Now there are no more nodes so all minus 1

03:26.610 --> 03:29.200
Yes I got the elements in the same order.

03:29.280 --> 03:33.660
Does the level of that's all.

03:33.680 --> 03:38.930
So I've just added one extra function to a pre program or project.















WEBVTT

00:00.350 --> 00:05.320
So the topic is can be generated 3D from private sales.

00:05.360 --> 00:10.770
So from traversal we want to generate the tree actually from the tree we find ever since.

00:10.770 --> 00:15.130
So if I already know traversal can generate a tree there are three times since.

00:15.150 --> 00:20.670
So we want to know that they're just pre order will help us generate the tree or not either just pull

00:20.670 --> 00:22.260
started can find or not.

00:22.380 --> 00:24.960
Or preorder a ball starter if they are given.

00:24.960 --> 00:26.260
Can we generate a tree.

00:26.340 --> 00:27.920
So finally we'll find out.

00:28.130 --> 00:34.770
Richard traversal SA compulsory so that we can generate a tree from those traverses.

00:34.800 --> 00:36.820
So that's what our discussion is.

00:36.900 --> 00:38.570
Which travel some are compulsory.

00:38.580 --> 00:39.450
So let us start.

00:40.320 --> 00:41.790
I have taken three notes here.

00:41.790 --> 00:46.510
These are three labor laws three label alongside them.

00:46.530 --> 00:55.310
Now suppose our tree with a tree in the war is having a preorder them as a B.

00:55.350 --> 00:59.480
No I have just a preorder traversal for the tree with the three n.

00:59.470 --> 01:01.980
Another question is from the preorder.

01:02.040 --> 01:04.790
Can we generate outrage or not.

01:04.950 --> 01:07.470
Let us check for that traversal.

01:07.530 --> 01:15.420
I will draw a tree with the 3 N A B C yes.

01:15.450 --> 01:16.880
What is the pre order of this.

01:17.040 --> 01:23.370
First a and b and c Yes I got a tree I'm able to generate.

01:23.370 --> 01:25.590
No let us check one more.

01:25.800 --> 01:36.710
If I draw our tree like this A B C because the preorder a b c I'm getting same preorder for this also

01:36.710 --> 01:52.000
I'm getting same preorder I tried this A B C for the soldier same preorder a B then C then that's fine

01:52.030 --> 02:01.710
preorder a b c I'm getting simply the ABC simply order from the preorder if we tried to generate a 3

02:02.060 --> 02:02.890
5.

02:02.890 --> 02:07.660
Trees are possible for three elements five P's are possible.

02:07.660 --> 02:12.150
Actually we want one tree one unique tree so we cannot generate touching.

02:12.150 --> 02:18.010
We cannot find out because there are multiple trees are possible which are giving same pre order for

02:18.010 --> 02:18.700
three elements.

02:18.730 --> 02:26.950
So conclusion is if only pre order is given we cannot challenge or claim but one observation is that

02:26.950 --> 02:28.210
the same pre order.

02:28.210 --> 02:30.570
How many different trees can be generated.

02:30.580 --> 02:32.140
One two three four five.

02:32.680 --> 02:35.170
If you remember these are five different shapes.

02:35.350 --> 02:36.110
Yes.

02:36.330 --> 02:42.400
If preorder is given only preorder is given then how many trees we can generate which are having same

02:42.400 --> 02:46.630
preorder 2 and C and by and plus 1.

02:46.630 --> 02:46.930
Yes.

02:46.930 --> 02:50.780
Get along the moral for treason can generate not one.

02:50.890 --> 02:55.830
Actually we've wanted one not possible next.

02:56.530 --> 02:58.750
What about if I give you an order.

02:58.750 --> 03:02.950
Same time same thing fighters I can generate.

03:03.050 --> 03:08.950
What about will start the same thing five different trees I can generate which will give me simple structure.

03:09.410 --> 03:11.450
So this is true.

03:11.450 --> 03:13.650
This is true for all traverses.

03:13.700 --> 03:16.820
If you give any traversal more than one trees are possible.

03:16.820 --> 03:24.960
So how many trees are possible which are satisfying seem traversal to NC and mindless fun not next Shall

03:24.960 --> 03:26.470
I give you two traversal.

03:26.490 --> 03:29.770
Can you generate a tree from two traverse cells.

03:29.790 --> 03:31.610
I have already given preorder.

03:31.650 --> 03:41.970
I'll give you both starter also boost order both starter is c b e so I am giving two tablets on this

03:41.970 --> 03:49.960
one and this one to traverses Can you generator three for those two traversal why does the preorder

03:50.650 --> 03:54.660
ABC preorder is ABC right.

03:54.850 --> 03:58.550
What is spool starter of this one CB CB.

03:59.620 --> 04:05.920
What is the preorder ABC preorder is ABC what is post starter.

04:07.960 --> 04:10.330
What is both startup from this site right.

04:11.420 --> 04:13.530
C B E.

04:13.750 --> 04:21.280
Who started this C B E C more than one trees are having same preorder and both starter.

04:21.950 --> 04:29.630
So if you give preorder and poster are also more than 1 3s can have same preorder and both starter so

04:29.630 --> 04:37.610
Richard 3 1 Actually we want a unique treat just one single tree one single tree submitted to preorder

04:37.610 --> 04:47.930
and for sure also it's not possible for that sole conclusion this if you just give preorder or both

04:47.940 --> 04:48.560
starter

04:51.070 --> 05:01.570
are in the order you cannot generate just 1 3 total to NC and buy and plus when trees are possible not

05:01.570 --> 05:03.310
1 3 you cannot generate.

05:03.310 --> 05:07.380
If this is given this one or this one or this one.

05:07.960 --> 05:16.170
If I give preorder and boost order then one plus I thought that is more than one.

05:16.180 --> 05:19.940
There's no formula for that because there are many possibilities in this fun.

05:20.050 --> 05:23.000
Many cases out there so there is no formula for this.

05:23.020 --> 05:25.420
I cannot tell you these many are short.

05:25.420 --> 05:26.870
No not possible.

05:27.310 --> 05:29.330
So more than one that is sufficient.

05:29.380 --> 05:34.750
So if only preorder then both started is given more than 1 by injuries are possible 1 3 is not possible

05:34.980 --> 05:38.650
then which your cover so can give me 3 so I'll write them here.

05:38.950 --> 05:41.670
Yes preorder plus in order.

05:42.730 --> 05:46.980
Either this one or second one for starter.

05:46.990 --> 05:48.140
Plus in order.

05:48.650 --> 05:49.500
Anyone.

05:49.520 --> 05:55.940
In order because in order to retain the root and demand for fossil gifts left than root than the right.

05:55.960 --> 06:00.460
So in order can help you if you know the root then what should go on left side.

06:00.460 --> 06:02.240
What should go on right side.

06:02.350 --> 06:07.130
It can help you decide the splitting of N in the left up to your right.

06:08.530 --> 06:13.500
That's why in order is mandatory alone in order will not help you alone.

06:13.510 --> 06:19.900
Pre or post mortem will not help you together preorder or start a roll so will not help you then in

06:19.900 --> 06:20.760
order is must.

06:20.980 --> 06:27.400
So conclusion is that one of the traversal must be in order and the other drivers can be either preorder

06:27.400 --> 06:28.030
or post.

















WEBVTT

00:00.540 --> 00:08.040
See the topic is a generating tree from Traverse since so already we have learned any two drivers set

00:08.040 --> 00:12.940
aside compulsory out of tact one of their drivers must be in order.

00:13.050 --> 00:18.880
So I have a pre order in order and one more possible this post of any order.

00:19.410 --> 00:23.050
Let us learn how to generate tree from order and in order.

00:23.980 --> 00:27.720
So I'll show you the procedure Creator Lord

00:30.730 --> 00:38.290
take all the elements off in order take in order as it is in the norm don't change order elements in

00:38.290 --> 00:39.360
the same order.

00:39.460 --> 00:47.050
7 6 9 3 4 5 8 2 1.

00:47.050 --> 00:48.150
As it is I have taken.

00:48.640 --> 00:57.790
This is initial work no repeating procedure means that those steps be repeating what little scandal

00:57.780 --> 01:02.770
pre order scandal preorder by taking one element at a time.

01:02.770 --> 01:08.410
Then what to do with each element let us see first step I am sure you dig the first element from left

01:08.410 --> 01:09.090
to right.

01:09.160 --> 01:10.810
So Foster element is Ford.

01:10.810 --> 01:16.320
So Ford is a road so you remember what will be the first element in preorder root of a tree.

01:16.360 --> 01:18.490
So Ford is the root of a tree.

01:18.490 --> 01:24.420
So search forward for search it is found observed once again.

01:24.430 --> 01:27.760
Search for 4 in this list of elements.

01:27.760 --> 01:29.090
Yes it is found here.

01:29.260 --> 01:33.280
So big food in one node.

01:33.410 --> 01:37.530
The fourth ruled then waterboard the rest of the elements.

01:37.670 --> 01:46.180
7 6 9 3 on the left hand side of 4 7 6 9 3 on the left hand side.

01:46.380 --> 01:49.910
And these elements on the right hand side 5 8 2 1.

01:49.940 --> 02:01.210
So 5 8 2 1 on the right hand side is we've got fast to nor that is fast rule nor if I tell you this

02:01.210 --> 02:10.940
step once again Foster Lehman search then split move to the next element 7 search for 7 and then 7 variant

02:10.960 --> 02:13.230
will be on the left side or right hand side.

02:13.400 --> 02:18.700
C ask for a preorder will be going on lefthand side if it is not found and will go on right side.

02:18.980 --> 02:24.440
So search and left can Sirius 7 this phone 7 is found then split.

02:24.590 --> 02:32.680
Ford was already there then left hand side left child is 7 no other elements 6 9 3 all of them are on

02:32.680 --> 02:39.240
the right hand side of 7 so it could take them on in a single load on the right hand side of 7.

02:39.320 --> 02:43.610
This part is as it is for searching and splitting.

02:43.670 --> 02:47.120
No let me do the rest of the laws quickly.

02:47.480 --> 02:53.690
Next element 9 search and is found either in this list or this list.

02:53.690 --> 02:55.520
This list found split.

02:56.270 --> 03:01.070
So here will draw 4 on the side and 7 on the left hand side.

03:01.160 --> 03:03.470
The 9 is on the right hand side of 7.

03:03.860 --> 03:06.580
Then what about the remaining element 6 entry.

03:06.590 --> 03:08.380
They are on the different sides of 9.

03:08.390 --> 03:15.690
So let's try and side dig 6 right Tyneside Dick 3 Yes 6 on the side.

03:15.690 --> 03:16.960
3 on this side.

03:17.310 --> 03:25.990
This is completed then the right hand side elements such as it is 5 8 2 1 5 8 2 1.

03:26.220 --> 03:31.660
Then move to the next element in 6 search it is found here and there is a single element.

03:31.680 --> 03:34.830
Yes we want single element only so it's perfect.

03:34.860 --> 03:42.010
Don't do anything next 3 3 search for 3 to found here under the single element.

03:42.210 --> 03:48.560
Don't do anything next element to search it is found here.

03:48.560 --> 03:49.190
Found here.

03:49.580 --> 03:51.860
So there are more than one element so split.

03:51.860 --> 03:53.410
So I will draw you here.

03:53.570 --> 03:58.880
So this site is already completed cyber targets.

03:58.880 --> 03:59.830
That is.

03:59.960 --> 04:05.450
And here new rule is to do so five and eight on the left hand side.

04:07.020 --> 04:09.530
Five and eight on the right hand side.

04:09.540 --> 04:16.490
One is next move on to the next element that is fine.

04:16.600 --> 04:18.760
Search for five it is found here.

04:18.860 --> 04:20.800
These two elements are there so split.

04:20.800 --> 04:21.790
I read right here.

04:22.390 --> 04:23.290
So 4.

04:23.920 --> 04:27.020
So this left hand side is as it is right hand side.

04:27.030 --> 04:32.920
2 and 1 as it is then this is the word I have to Big 5.

04:33.110 --> 04:34.690
OK big fine.

04:35.140 --> 04:36.360
What about 8.

04:36.380 --> 04:40.920
There should be is on the right hand side in the north circle will go on the right hand side only.

04:41.140 --> 04:42.860
So this is on the right hand side.

04:44.260 --> 04:49.850
Continue 8 search for it single element don't do anything.

04:49.880 --> 04:52.540
Well next one search for one follow.

04:52.600 --> 04:55.430
Similarly my that song.

04:55.510 --> 04:57.680
This is a tree.

04:58.030 --> 04:59.920
This is a unique tree.

05:00.070 --> 05:03.370
Just one single tree for this tree.

05:03.370 --> 05:06.460
This is the preorder and this is in order.

05:06.460 --> 05:12.070
There is no other tree possible which give same pre order and in order so there's a unique tree so we

05:12.070 --> 05:17.380
are able to generate a unique tree for preorder and then order is given and this is the procedure.

05:17.590 --> 05:22.690
So this was the first step and the second step We have taken for and the third step.

05:22.690 --> 05:28.420
We have split at 7 because we are moving along from lefthand side to right and said we were scanning

05:28.420 --> 05:32.920
pre order from left to right then forward the step.

05:32.990 --> 05:37.610
We have begun nine so automatically got six and three also.

05:37.640 --> 05:40.190
So this also completed the next.

05:40.220 --> 05:41.700
Here we selected two.

05:41.810 --> 05:43.870
This was forward the fifth.

05:43.910 --> 05:45.730
Then this is 7 the step I should say.

05:46.760 --> 05:53.040
So in this is step 2 was splitter then eight this step in this a five was a splitter.

05:53.060 --> 05:55.560
So even eight was also stated.

05:56.510 --> 05:57.650
We got our tree.

05:57.650 --> 06:00.770
This is the procedure my analysis.

06:00.770 --> 06:02.820
What is the time complexity.

06:02.900 --> 06:04.160
How much time it is taking.

06:04.560 --> 06:06.270
So actually we have the boardwalk.

06:06.380 --> 06:12.710
We have not eaten any gourd or the pseudocode or algorithm just based on the procedure only we have

06:12.710 --> 06:13.400
to give the time.

06:13.520 --> 06:15.140
So what was the work done.

06:15.140 --> 06:19.760
We have scanned through preorder all the elements we have scanned for them once.

06:19.760 --> 06:23.020
So this is an yes.

06:23.220 --> 06:27.970
But widely scanning for every element of what we were doing searching for that element here to make

06:27.970 --> 06:28.720
it possible.

06:28.900 --> 06:30.670
Or make it the new node.

06:30.670 --> 06:33.080
So we were searching for the element every time.

06:33.130 --> 06:35.620
So for every element we were searching.

06:35.620 --> 06:40.840
So searching takes how much time and time for how many times we have search for every element we have

06:40.840 --> 06:50.030
so so and then go in searching certain digging in time right search takes and 9 and how many times we

06:50.030 --> 06:52.890
have done for any elements we have done.

06:52.940 --> 06:56.500
So there are any elements so an element search for end time.

06:56.520 --> 06:58.590
So this is in square.

06:58.850 --> 07:01.660
So the time taken by this procedure is in the square

07:04.450 --> 07:07.180
so that's all about this procedure.

07:07.540 --> 07:10.360
So generating a tree from Traverse sense is very important.

07:11.830 --> 07:13.560
I will show you the program for this one.


















WEBVTT

00:00.620 --> 00:06.840
In this video we learn about a function for counting lords in our binary tree.

00:06.930 --> 00:11.100
So already I have an example by near a tree and also a function at a level.

00:11.640 --> 00:13.640
And this function is recursive.

00:13.890 --> 00:20.100
So just I will explain how this function books let us trace the function to understand the working of

00:20.100 --> 00:23.610
a function so that you can write on similar functions.

00:23.610 --> 00:24.430
If you require.

00:24.720 --> 00:28.710
Let me read out this function and explain a few things then I will show you.

00:28.710 --> 00:36.630
Placing function names count and I have taken some temporary variable sex and why do the local dual

00:36.640 --> 00:42.320
function point on the MSP that should be at nought point.

00:43.880 --> 00:55.040
If base not null if these not go then calling itself upon left chime gong itself upon the right chain

00:55.480 --> 00:56.620
get there is enough left.

00:56.620 --> 00:58.560
Charlie next get the result off right.

00:58.570 --> 01:07.090
Charlie in line to function calls on left channels so they chat also then for counting every Nord plus

01:07.090 --> 01:14.010
one should be added for every node like one first nor second or third or one by one you have to go on

01:14.010 --> 01:19.860
adding surveyor adding it's done whatever the result of left hand site plus whatever the result of right

01:19.860 --> 01:21.260
time site plus 1.

01:22.340 --> 01:28.160
This small number of nodes on that site number of nodes on the right side then plus 1.

01:28.160 --> 01:35.060
This Node 2 I have just read it out so it makes sense that this is counting the number of nodes and

01:35.060 --> 01:40.260
it is doing the recursively it is calling itself if a PS not null.

01:40.280 --> 01:41.320
Do all these things.

01:41.360 --> 01:43.110
If it does no at this part.

01:43.160 --> 01:48.110
The sentence part I don't have to write ls because if it senses having written so I don't have to write

01:48.110 --> 01:51.900
downs even you can write ls that inside that you can write this.

01:52.010 --> 01:57.980
Return 0 means if there is no nought if it is no longer conceivable then one important thing you have

01:57.980 --> 02:04.550
to show your counting often or this is done in this line in this a statement just look at this and before

02:04.550 --> 02:06.960
counting it is going on left children right check.

02:07.670 --> 02:12.140
So first left then right then God I'll change it.

02:12.140 --> 02:13.250
Just listen.

02:13.250 --> 02:14.690
First left then right.

02:14.720 --> 02:15.630
Then print.

02:16.340 --> 02:19.590
What is this first left then right then print.

02:19.640 --> 02:20.600
This is both starter.

02:20.990 --> 02:21.730
Yes.

02:21.770 --> 02:25.890
This procedural dysfunction is working in post started form.

02:26.300 --> 02:32.110
This is working in poor starter form and wanting ever tell you what all the processing you want to do.

02:32.120 --> 02:42.240
Upon binary trees most of the time you have to use both start or form supposed start that is more commonly

02:42.240 --> 02:45.720
used up on by name trees for doing any type of processing.

02:46.470 --> 02:50.900
So now let me trace the essential you so that you know how recursive function works.

02:50.910 --> 02:56.490
I will not spend much time quickly having true tracing so I'm sharing your tracing up one tree directly

02:56.700 --> 03:02.460
so far the root function is called upon the root then Brutus not null yes not null.

03:02.460 --> 03:04.280
What are the steps when it is not known.

03:04.290 --> 03:13.220
Three steps I did find X find Y then add them plus 1 and that are done so fast find X find x call on

03:13.220 --> 03:20.510
the left child first finish first step then you go on second step like fast finish faster step faster

03:20.650 --> 03:27.350
golf tournaments it will come on the small upon this note this is not name so again X assign X assign

03:27.770 --> 03:32.310
call upon left child whatever the result you get to pick it of X OK.

03:32.330 --> 03:33.690
Again you discard here.

03:33.950 --> 03:40.610
So this is not null on the left side X assign call up on left side.

03:40.630 --> 03:41.690
Let's say this walk.

03:41.740 --> 03:43.250
None here.

03:43.250 --> 03:46.000
Left side is none here and there fighting the elements.

03:46.000 --> 03:47.860
What is the result from this one.

03:48.030 --> 03:48.800
Zero.

03:48.820 --> 03:50.880
If it is not known it is entering here.

03:50.950 --> 03:53.070
If it is not then it will return zero.

03:53.080 --> 03:55.310
So from this site the result will be zero.

03:55.310 --> 03:58.370
I'll just extend and show you the site result will be zero.

03:58.570 --> 04:06.330
So this X will convince evil it has scarred itself on the left side which was null so the value of x

04:06.330 --> 04:09.330
is zero for which node nor the two ends.

04:09.470 --> 04:15.390
So far this step is finished for an order to well then perform second step Y is equal to right.

04:15.390 --> 04:19.680
Charity Y is equal to right chain.

04:19.740 --> 04:23.720
There is a node so far this new called Fresh call.

04:23.730 --> 04:29.180
So again for this node x x assign left China.

04:29.990 --> 04:31.410
For this left child.

04:31.410 --> 04:32.690
Again it is not known.

04:32.850 --> 04:35.430
So X a sine left child.

04:35.580 --> 04:38.400
So for this left nothing is there null zero.

04:38.400 --> 04:41.540
So this will be zero then for right for right.

04:41.540 --> 04:42.840
Also it is zero.

04:42.990 --> 04:47.050
Now for this node 9 two steps out or first step second step.

04:47.130 --> 04:50.010
Then third step x plus like plus 1.

04:51.700 --> 04:59.980
Zero plus zero plus one isolate done it will go to this morgue in which variable X because it was called

04:59.980 --> 05:05.290
on left side 1 then on the side y for this side X.

05:05.410 --> 05:12.640
There is nothing none so zero Y zero zero below zero plus one one is re done not for this nor the left

05:12.640 --> 05:19.540
hand side x value also ignores Y also eight miles to see I said it doesn't start out right so this left

05:19.660 --> 05:26.560
right completed then vote one plus one plus one three.

05:26.560 --> 05:29.760
See this is giving the number of nodes below this one.

05:30.190 --> 05:34.480
Now this is really zero plus three three plus one for.

05:34.540 --> 05:43.720
So for the right side why this is zero there is nothing on this site no go back four plus 1 4 0 plus

05:43.720 --> 05:52.390
1 5 5 see below this check one two three four five five nodes are there then go on the right hand side

05:53.290 --> 05:59.230
then up on this one left hand side up on this one left hand side null zero what I can say is zero zero

05:59.380 --> 06:11.060
zero plus one one goes back to this one then on the side away left side X left side x 0 y 0 0 0 plus

06:11.060 --> 06:18.590
1 0 0 plus 1 goes back one this side why is zero now these two are added and redone one so one plus

06:18.590 --> 06:21.460
zero one plus one two two.

06:21.680 --> 06:28.860
One two three three plus one for no five plus four nine plus one ten Sudan's system.

06:29.210 --> 06:35.540
So that's all this is working in poor startup I'll make one small change in the score right then you

06:35.540 --> 06:39.430
have to tell me what this function will do here.

06:39.620 --> 06:51.260
I was right on the statement if B cab and child and B gap are child Vince B is a left child is that

06:51.260 --> 06:53.600
there is not no right.

06:53.630 --> 07:09.130
Child is also not known then gone x plus life plus one else I read on X plus Y then this F ends this

07:09.200 --> 07:10.900
F and at last.

07:11.050 --> 07:20.600
Write down zero guess what the story to this condition this condition is for board left and right.

07:20.620 --> 07:26.480
Chapter dear so it means of border children are there then only it will come to one otherwise one is

07:26.480 --> 07:32.990
not content means that nor does not contact so will count only those n who are having board the children

07:33.470 --> 07:39.530
so n with the degree to from the street with N will be conquered eight is having the children four is

07:39.530 --> 07:45.800
having the children five is having the children so only three notes will be content so this will count

07:45.800 --> 07:50.830
the number of n which are having both the children left side as well as right side.

07:50.990 --> 07:57.080
This I have introduce one condition and it became a condition for counting nor so the degree to change

07:57.080 --> 08:04.470
the condition who can live n change the condition to count n for the degree one whatever you like you

08:04.470 --> 08:05.350
can do next.

08:05.610 --> 08:14.130
I will make one more change every on there are no if else x plus y plus Besa Deda.

08:14.160 --> 08:15.580
Can you tell me what will happen.

08:15.660 --> 08:22.050
These details that it is it will add all these elements from my tree you will get the sum of all the

08:22.050 --> 08:28.770
elements in that tree that stood and exercise here I'm modifying the code so don't know what the function

08:28.770 --> 08:37.380
is doing okay function name I will call it as fun and this is fun this calling itself fun is calling

08:37.380 --> 08:49.440
itself I am modifying it if x is greater than y right on X plus one else read on like this one take

08:49.440 --> 08:57.960
this and find out what this function is doing what this function is doing just not adding x and y bought

08:58.230 --> 09:05.040
either x plus 1 are like this one so far understanding or knowing what that function is doing you have

09:05.040 --> 09:08.870
to trace it up on a tree and observe eurozone then you can find out.

09:08.880 --> 09:14.900
So for example you can take this tree that if you take just two three nodes you will not feel able to

09:14.900 --> 09:20.330
figure out what it is doing take this type of tree and trace that one and find out.

09:20.630 --> 09:24.200
So that's all we have seen various functions upon a tree.

09:24.800 --> 09:29.360
I have started with the county but I have also shown you different functions on this one.












WEBVTT

00:00.540 --> 00:06.440
In this video we will write our recursive function for counting the number of nodes in a binary tree.

00:06.550 --> 00:10.580
I'd also like to request a function for finding the height for binary tree.

00:10.600 --> 00:17.380
This project the same project that we have used for creating a tree or forming traverse cells and also

00:17.380 --> 00:19.120
for level order traversal.

00:19.120 --> 00:25.030
Same program I'm using here just here before the main function I've ever done a function for counting

00:25.030 --> 00:27.580
number of nodes in a binary tree.

00:27.700 --> 00:30.160
So it should take a pointer to a root.

00:30.250 --> 00:31.360
So I was named as root.

00:31.360 --> 00:43.600
Only then if a root is not another then it should read on call itself long on roots l child

00:46.180 --> 00:51.190
plus down good cell phone rules right.

00:51.210 --> 01:00.500
Child plus 1 otherwise redone Zito it.

01:00.720 --> 01:07.220
And also I have right to function so finding the height height struck Nord

01:09.800 --> 01:13.120
root if root is equal to zero.

01:13.130 --> 01:13.940
That is null.

01:14.020 --> 01:21.220
Then return 0 otherwise I need two variables x and y.

01:21.290 --> 01:24.210
These I will assign them to 0 initially.

01:24.340 --> 01:28.690
Then call the function of simply upon left child.

01:28.700 --> 01:38.340
That is rules l child and Y height rules right.

01:38.380 --> 01:41.450
Child then whichever is greater.

01:41.460 --> 01:47.320
If x is greater than y All right on X plus 1.

01:47.340 --> 01:52.180
Otherwise return lifeless one next fall.

01:52.230 --> 01:57.600
This is for fighting height and also we have read in the function for counting n print f.

01:57.660 --> 02:06.310
I will display first count so all the function count and root then print f

02:09.080 --> 02:09.790
height.

02:10.220 --> 02:11.270
But it's entirely

02:15.190 --> 02:16.600
height of fruit.

02:19.140 --> 02:23.820
Now let us run this program and see be it a tree.

02:23.950 --> 02:28.700
So oldest 10 left child is 20 right and is 30.

02:28.710 --> 02:36.230
Oldest left child is a 40 then this right child is 50 and 30 is not having any children.

02:38.600 --> 02:40.710
40 is not having any children.

02:40.760 --> 02:42.200
50 is having a child.

02:42.240 --> 02:43.120
60.

02:43.660 --> 02:44.100
And right.

02:44.100 --> 02:47.970
Child is not the 60s left child and Rachel are not there.

02:47.970 --> 02:55.080
So the number of notes I have created are 6 and the height is 4 so you can draw this tree on paper and

02:55.080 --> 03:01.560
check it and you can enter the values and verify that the results written by this function.

03:01.590 --> 03:03.730
That is count and height.

03:04.380 --> 03:08.480
So try this program by yourself already we have seen it's working and everything on board.

03:09.770 --> 03:13.240
So this is just a demonstration so you can practice this program.

03:13.460 --> 03:14.470
That's all in the studio.












WEBVTT

00:00.150 --> 00:05.560
In this video we will see how to ConEd Leaf North and non leaf n order north.

00:05.560 --> 00:13.620
With a degree zero no degree one or n for the degree to see for this example three these are leaf notes

00:13.710 --> 00:14.100
right.

00:14.100 --> 00:17.550
These are leaf notes and these are all long leaf notes.

00:17.550 --> 00:18.990
So these are with the degree zero.

00:19.290 --> 00:22.260
So these are leaf notes and degree more than zero.

00:22.260 --> 00:28.770
They are not leaf notes and these are with the degree to this degree to write and is a degree to and

00:28.830 --> 00:30.320
these notes are with the degree one.

00:30.360 --> 00:32.550
This is one like and this one.

00:32.550 --> 00:34.870
So that's what we want to count.

00:35.100 --> 00:38.600
We have already seen the recursive function for counting the number of nodes.

00:38.640 --> 00:44.100
And this was the function already I have shown you the tracing of this one in the same function if I

00:44.100 --> 00:48.240
modify make some changes I can count leaf n.

00:48.750 --> 00:52.310
So let us make changes for various types of N.

00:52.410 --> 01:00.270
So first one is leaf N C when you say a notice leaf n if left child is null and I child is not so I

01:00.270 --> 01:01.360
will remove this line.

01:01.760 --> 01:11.580
Okay and remove this line and here I will see if n left child is null as well as a child is none so

01:12.000 --> 01:24.130
B's l child is equal still null if it is known as well as B's are child like is equal to none

01:27.550 --> 01:37.170
then if both are null then I will count back Nord 500 on x plus y plus one other otherwise means if

01:37.170 --> 01:44.290
any if any one of the condition fails then it will not enter here then what I should be done I should

01:44.290 --> 01:47.050
read on X plus Y.

01:47.190 --> 01:55.690
That's on see if these are true then add one otherwise ways don't go to one so it will add one only

01:55.690 --> 01:59.260
for those n whose board left can right child are null.

01:59.680 --> 02:08.900
So this will become deep leaf n and after this if we can't return 0 means if a node is null return 0.

02:08.980 --> 02:11.970
So this is already there we have already seen it.

02:12.280 --> 02:19.420
So just by adding one condition in the same function for count we can change this function for counting

02:19.750 --> 02:24.870
leaf n so leaf N R with a degree 0 or so.

02:24.870 --> 02:32.630
This function is for counting nodes for the degrees 0 next as counting nodes for the degree to.

02:33.130 --> 02:36.250
So what changes have to do so inside this function.

02:36.280 --> 02:42.100
I should say bees left child is not equal to null and the bees right.

02:42.100 --> 02:44.590
Child is also not equal to none.

02:44.770 --> 02:49.970
If both are not null then these are n with the degree to.

02:50.090 --> 02:55.290
So this more on this note of this note so far this tree I will get the other data tree.

02:55.290 --> 03:02.530
There are three n with the degree to this also finding n for the degree to suggest change of condition

03:02.740 --> 03:03.850
that is sufficient.

03:03.850 --> 03:08.230
So if this is true both left children a child both are their count.

03:08.320 --> 03:09.220
Otherwise don't count.

03:10.890 --> 03:19.420
One counting north with the degree to as well as of one means if a all is having any one child conflict

03:19.780 --> 03:23.750
means this note should be counted because this is no this is not known.

03:23.860 --> 03:25.380
This is not the system.

03:25.390 --> 03:26.360
Both are not done.

03:26.740 --> 03:32.270
So far that I simply have to change this condition as are now.

03:32.350 --> 03:41.530
This works for counting north for their degree one and two for all internal laws so that's it.

03:41.560 --> 03:42.930
This is sufficient.

03:42.960 --> 03:47.950
Now next I will show you how to write the condition for counting north.

03:47.950 --> 03:54.040
Those North who's a degree is one so only as a matter of changing the conditions I will remove this

03:54.040 --> 03:55.030
function.

03:55.030 --> 04:00.890
And here I will write on all the conditions for leaf nor non leaf node all the conditions I will items.

04:00.970 --> 04:02.560
So let us see the conditions.

04:02.650 --> 04:06.700
See first one leaf node condition for leaf node condition.

04:06.700 --> 04:11.830
If a piece left China right is equal to none.

04:11.830 --> 04:12.850
So for that I can write.

04:12.850 --> 04:16.260
Not as often as BS right.

04:16.270 --> 04:19.780
China should be equal to none so for that I can write.

04:19.780 --> 04:22.050
Not this is four leaf node.

04:22.850 --> 04:28.090
And nor do it the degree to degree do so here.

04:28.090 --> 04:32.970
Condition is effort BS and child is not equal to none.

04:32.980 --> 04:37.660
So I don't have to write anything so it is not equal to not only we have all it is learnable.

04:37.660 --> 04:40.790
This one right the next is a piece of china.

04:41.380 --> 04:46.250
If both are true then this is 4 degrees 2 degree 2.

04:46.390 --> 04:51.850
Then the third one degree one are two.

04:51.900 --> 04:59.100
So for this the condition is if a piece of left child is not num are B's right.

04:59.100 --> 05:03.830
Child is not the condition.

05:03.960 --> 05:07.050
This is for exactly degree zero.

05:07.110 --> 05:16.160
Great exactly degree to this is to order one then last one exactly degree one.

05:16.260 --> 05:23.610
So exactly degree one means if it is not having left child it must have a child or if it is having left

05:23.610 --> 05:24.980
child it should not have right.

05:24.990 --> 05:26.730
Child does not condition.

05:26.760 --> 05:33.810
So for that I a right on the condition here that is food condition for degree exactly one so the condition

05:33.870 --> 05:49.530
is if a BS child right is not equal to no then and definitely B is our child should be equal to no right.

05:49.670 --> 05:50.990
This is one condition.

05:51.020 --> 05:58.190
I'll put it in brackets ah the second part ah if a piece of left childless and no then this should not

05:58.190 --> 05:58.490
be that.

05:59.390 --> 06:06.670
So I will write on and the next line I will trade on BS l child is equal to none.

06:06.800 --> 06:13.370
See earlier we have written not equal to null here I have it not equal to none so no it is equal to

06:13.380 --> 06:24.010
null and B's our child should not be equal don't write our child not equal to none this is how we can

06:24.010 --> 06:32.960
vote on the condition for exactly one child that is degree 1 See this is too much Lindy.

06:33.330 --> 06:35.260
Can we reduce the sights.

06:35.290 --> 06:40.990
See this is and the condition is a condition contamination from here to here as a single condition.

06:40.990 --> 06:44.970
This also should be in the bracket and this is very Lindy.

06:45.090 --> 06:49.940
Can we reduce it files remove this and show you how I can reduce this one.

06:49.970 --> 06:56.840
So this you can take it if you want to know Don you can not on this one but this one I will try it once

06:56.840 --> 06:57.290
again.

06:57.290 --> 07:01.600
This one is just light if left child is there then right.

07:01.600 --> 07:02.870
Change should not be there.

07:03.140 --> 07:03.650
Right.

07:03.650 --> 07:12.950
This part R R if left childless not their right child must be dead left child is not a child must be

07:12.950 --> 07:13.280
dead.

07:13.940 --> 07:14.940
So what is this.

07:14.970 --> 07:23.280
This doesn't nothing but an exclusive R R L exclusive R and R.

07:23.420 --> 07:26.650
So this is with left and right r exclusive R.

07:26.900 --> 07:31.290
So is there any exclusive R operation in C C++ right.

07:31.310 --> 07:32.020
Like languages.

07:32.050 --> 07:33.020
Yes they have.

07:33.110 --> 07:33.910
What is that.

07:33.920 --> 07:36.140
So I will write on this condition once again here.

07:36.140 --> 07:39.460
So here is a PS l child.

07:39.790 --> 07:40.530
Right.

07:40.550 --> 07:42.330
It's not equal to no.

07:42.410 --> 07:45.970
This is El XOR.

07:46.480 --> 07:50.970
These are child not equal to none.

07:51.040 --> 07:51.570
This is.

07:51.570 --> 07:53.360
Ah yes.

07:53.420 --> 07:57.310
This cat is a symbol used for exclusive PAs.

07:57.860 --> 08:02.840
So I have revealed this lending condition and or symbol condition like this.

08:03.260 --> 08:06.160
So this is the condition for degree one.

08:06.830 --> 08:10.310
So that's all we have finished with all various type of conditions.

08:10.310 --> 08:14.510
Now called function I have shown you by using accent y variables.

08:14.510 --> 08:19.450
It can also get it done without using those variable so it can be done in a simple form also.

08:19.460 --> 08:25.670
So I will show you the other ways how you can write on the same recursive function on slide on the function

08:26.180 --> 08:28.450
C function limits come.

08:28.510 --> 08:35.670
So I will call it unaccountably which is sticking are pointed to a node struct more pointer B key.

08:35.810 --> 08:41.570
I will not take any variable 6 and might simply first I will check the condition if B is equal to nine

08:42.230 --> 08:46.040
minutes if it is no then over that if it is null then return 0.

08:46.300 --> 08:46.730
OK.

08:46.760 --> 08:51.920
This over Alice I don't have to write because inside the condition there is a written statement.

08:51.920 --> 08:54.290
So if it is true it will read on function will stop.

08:54.290 --> 08:55.880
It will never come here.

08:55.880 --> 08:59.170
So like I can write on the chord without writing else.

08:59.330 --> 09:09.550
So let us see just see written and bees and child right.

09:09.680 --> 09:20.140
Plus gunned bees on child on child plus one.

09:20.180 --> 09:22.740
This song does is so simple.

09:23.090 --> 09:24.450
See left child right.

09:24.470 --> 09:25.620
Child plus one.

09:25.910 --> 09:30.330
Earlier I was taking these values in accent y variables then I was adding 1.

09:30.340 --> 09:32.750
So now it can be written directly.

09:32.750 --> 09:36.320
I'm calling the function and are actually also calling the function plus 1.

09:36.980 --> 09:38.470
So the working will be same.

09:38.540 --> 09:44.330
So there's a another way you can write on this one then regarding Leif Norden only floor here I should

09:44.330 --> 09:48.750
have a condition that is if it is a leaf node condition plus 1.

09:48.810 --> 09:51.660
Otherwise one more time I should write on count left right.

09:52.130 --> 09:54.300
And without writing plus I should try it on.

09:54.380 --> 10:07.860
See for example here I will write if B L child and B are 9 not not not so this is for me if not condition

10:08.460 --> 10:19.110
either 1 otherwise I write on count B's left child plus count B's right.

10:19.150 --> 10:19.510
Child

10:22.530 --> 10:24.740
let 5.

10:24.950 --> 10:30.140
So this is the common function for we have learned how to find the number of leaf nodes and the number

10:30.140 --> 10:31.280
of long leaf notes.

10:31.280 --> 10:32.720
So you can practice this program.













































































